{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SeapoPym Documentation","text":"<p>Welcome to the SeapoPym documentation! SeapoPym is a Python implementation of the SEAPODYM (Spatial Ecosystem And POpulation DYnamics Model) focusing on low and mid trophic levels of marine ecosystems.</p>"},{"location":"#overview","title":"Overview","text":"<p>SeapoPym provides a flexible framework for simulating spatial ecosystem dynamics using modern Python tools:</p> <ul> <li>Modern Python stack: Built with Xarray, Dask, and Numba for high-performance computing</li> <li>High-performance computing: Numba JIT compilation for efficient numerical computations</li> <li>Parallel processing: Dask support for large-scale simulations</li> <li>CF-compliant data: Xarray-based structures with pint-xarray for units</li> <li>Scientific reproducibility: Production-quality code accompanying our GMD publication</li> </ul>"},{"location":"#the-no-transport-model","title":"The No-Transport Model","text":"<p>This documentation focuses on the No-Transport Model, which simulates local ecosystem dynamics without advection. This model is ideal for:</p> <ul> <li>Understanding fundamental ecosystem processes</li> <li>1D vertical simulations</li> <li>Parameter sensitivity studies</li> <li>Learning the SeapoPym framework</li> </ul> <p>Get Started \u2192</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use SeapoPym in your research, please cite:</p> <pre><code>@article{lehodey2026seapopym,\n  title={SeapoPym v0.1: Implementation of the SEAPODYM low and mid trophic levels in Python with a flexible optimisation framework},\n  author={Lehodey, J.V.},\n  journal={Geoscientific Model Development},\n  year={2026}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>SeapoPym is open-source software licensed under the GNU General Public License v3.0 or later (GPLv3+).</p>"},{"location":"#support","title":"Support","text":"<ul> <li>\ud83d\udcda Documentation</li> <li>\ud83d\udcac GitHub Discussions</li> <li>\ud83d\udc1b Issue Tracker</li> </ul>"},{"location":"about/citation/","title":"Citation","text":"<p>If you use SeapoPym in your research, please cite our Model Description Paper:</p>"},{"location":"about/citation/#bibtex","title":"BibTeX","text":"<pre><code>@article{lehodey2026seapopym,\n  title={SeapoPym v0.1: Implementation of the SEAPODYM low and mid trophic levels in Python with a flexible optimisation framework},\n  author={Lehodey, J.V.},\n  journal={Geoscientific Model Development},\n  year={2026},\n  publisher={Copernicus Publications}\n}\n</code></pre>"},{"location":"about/citation/#text-format","title":"Text Format","text":"<p>Lehodey, J.V. (2026). SeapoPym v0.1: Implementation of the SEAPODYM low and mid trophic levels in Python with a flexible optimisation framework. Geoscientific Model Development.</p>"},{"location":"about/citation/#doi","title":"DOI","text":"<p>The paper DOI will be added here upon publication.</p>"},{"location":"about/citation/#software-citation","title":"Software Citation","text":"<p>For citing the software specifically:</p> <pre><code>@software{seapopym2026,\n  author = {Lehodey, Jules V.},\n  title = {SeapoPym: Spatial Ecosystem And POpulation DYnamics Model},\n  year = {2026},\n  url = {https://github.com/SeapoPym/seapopym},\n  version = {0.1.0}\n}\n</code></pre>"},{"location":"about/citation/#reproducibility","title":"Reproducibility","text":"<p>The exact code used in the GMD paper is available in this repository under the tag <code>v0.1.0</code>:</p> <pre><code>git clone https://github.com/SeapoPym/seapopym.git\ncd seapopym\ngit checkout v0.1.0\n</code></pre> <p>Notebooks reproducing the paper results are in the <code>paper_workflow/</code> directory.</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>We welcome contributions to SeapoPym! This page explains how to contribute.</p>"},{"location":"about/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>\ud83d\udc1b Report bugs and issues</li> <li>\ud83d\udca1 Suggest new features or improvements</li> <li>\ud83d\udcd6 Improve documentation</li> <li>\ud83d\udd2c Add examples or tutorials</li> <li>\ud83d\udcbb Submit code contributions</li> </ul>"},{"location":"about/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Create a new branch for your contribution</li> <li>Make your changes</li> <li>Submit a pull request</li> </ol> <pre><code># Fork on GitHub, then:\ngit clone https://github.com/YOUR-USERNAME/seapopym.git\ncd seapopym\ngit checkout -b feature/my-contribution\n\n# Make changes\n# ...\n\ngit add .\ngit commit -m \"Description of changes\"\ngit push origin feature/my-contribution\n</code></pre>"},{"location":"about/contributing/#development-setup","title":"Development Setup","text":"<p>Install development dependencies:</p> <pre><code>uv sync --group dev --group docs\n</code></pre> <p>This installs: - Testing: pytest, pytest-cov - Linting: ruff, mypy - Documentation: mkdocs, mkdocs-material</p>"},{"location":"about/contributing/#code-style","title":"Code Style","text":"<p>We use <code>ruff</code> for linting and formatting:</p> <pre><code># Format code\nuv run ruff format .\n\n# Check for issues\nuv run ruff check .\n</code></pre>"},{"location":"about/contributing/#running-tests","title":"Running Tests","text":"<p>Before submitting, ensure tests pass:</p> <pre><code># Run all tests\nuv run pytest packages/seapopym/tests/\n\n# With coverage\nuv run pytest --cov=seapopym packages/seapopym/tests/\n</code></pre>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>If you add features, please update documentation:</p> <pre><code># Build docs locally\nuv run mkdocs serve\n\n# View at http://localhost:8000\n</code></pre>"},{"location":"about/contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>A good pull request:</p> <ol> <li>Focuses on a single issue - One feature or bug fix per PR</li> <li>Includes tests - New features should have tests</li> <li>Updates documentation - Document new features</li> <li>Follows code style - Run ruff before submitting</li> <li>Has a clear description - Explain what and why</li> </ol>"},{"location":"about/contributing/#pr-template","title":"PR Template","text":"<pre><code>## Description\nBrief description of changes\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Code refactoring\n\n## Testing\nHow were these changes tested?\n\n## Checklist\n- [ ] Tests pass\n- [ ] Documentation updated\n- [ ] Code formatted with ruff\n</code></pre>"},{"location":"about/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting bugs, please include:</p> <ul> <li>Python version and operating system</li> <li>SeapoPym version</li> <li>Minimal code to reproduce the issue</li> <li>Expected vs actual behavior</li> <li>Error messages (if any)</li> </ul>"},{"location":"about/contributing/#feature-requests","title":"Feature Requests","text":"<p>For feature requests, please describe:</p> <ul> <li>The problem you're trying to solve</li> <li>Your proposed solution</li> <li>Any alternatives you've considered</li> <li>How this benefits other users</li> </ul>"},{"location":"about/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful and constructive. We aim to foster an open and welcoming environment for all contributors.</p>"},{"location":"about/contributing/#questions","title":"Questions?","text":"<p>Not sure where to start? Open a discussion on GitHub or reach out to the maintainers.</p>"},{"location":"about/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under GPLv3+.</p>"},{"location":"about/license/","title":"License","text":"<p>SeapoPym is free and open-source software licensed under the GNU General Public License v3.0 or later (GPLv3+).</p>"},{"location":"about/license/#what-this-means","title":"What This Means","text":"<p>You are free to:</p> <ul> <li>\u2705 Use the software for any purpose</li> <li>\u2705 Study how the software works and modify it</li> <li>\u2705 Distribute copies of the software</li> <li>\u2705 Distribute modified versions of the software</li> </ul> <p>Under the following terms:</p> <ul> <li>\ud83d\udccb You must preserve the copyright notice and license</li> <li>\ud83d\udd13 You must make source code available when distributing</li> <li>\ud83d\udd04 Modified versions must also be licensed under GPLv3+</li> <li>\u2696\ufe0f You provide the software \"as is\" without warranties</li> </ul>"},{"location":"about/license/#full-license-text","title":"Full License Text","text":"<p>The complete license text is available in the LICENSE file in the repository.</p>"},{"location":"about/license/#why-gplv3","title":"Why GPLv3?","text":"<p>We chose GPLv3 to ensure that:</p> <ol> <li>Scientific software remains open and accessible</li> <li>Improvements and modifications benefit the community</li> <li>Research reproducibility is maintained</li> <li>Commercial use is possible while keeping code open</li> </ol>"},{"location":"about/license/#academic-use","title":"Academic Use","text":"<p>For academic research, this license ensures:</p> <ul> <li>You can use SeapoPym in your research freely</li> <li>You can modify it for your specific needs</li> <li>You must share your modifications if you distribute your code</li> <li>You should cite our work (see Citation)</li> </ul>"},{"location":"about/license/#commercial-use","title":"Commercial Use","text":"<p>Commercial use is permitted under GPLv3, but:</p> <ul> <li>Modifications must be released under GPLv3</li> <li>Source code must be provided to users</li> <li>The GPLv3 terms must be maintained</li> </ul> <p>For commercial licensing inquiries, please contact the authors.</p>"},{"location":"about/license/#dependencies","title":"Dependencies","text":"<p>SeapoPym depends on several open-source packages with compatible licenses:</p> <ul> <li>Xarray, Dask, NumPy: BSD-3-Clause</li> <li>Numba: BSD-2-Clause</li> <li>DEAP: LGPL-3.0</li> <li>Pint: BSD-3-Clause</li> </ul> <p>All dependencies are compatible with GPLv3.</p>"},{"location":"about/license/#questions","title":"Questions?","text":"<p>If you have questions about licensing, please open an issue on GitHub.</p>"},{"location":"api/seapopym-optimization/","title":"Optimization API Reference","text":""},{"location":"api/seapopym-optimization/#algorithm","title":"Algorithm","text":""},{"location":"api/seapopym-optimization/#genetic-algorithm","title":"Genetic Algorithm","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm","title":"<code>seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm</code>","text":"<p>This module contains the main genetic algorithm functions that can be used to optimize the model.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithmParameters","title":"<code>GeneticAlgorithmParameters</code>  <code>dataclass</code>","text":"<p>The structure used to store the genetic algorithm parameters.</p> <p>Can generate the toolbox with default parameters. parameters.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithmParameters--parameters","title":"Parameters","text":"<p>MUTPB: float     Represents the probability of mutating an individual. It is recommended to use a value between 0.001 and 0.1. ETA: float     Crowding degree of the mutation. A high eta will produce a mutant resembling its parent, while a small eta will     produce a solution much more different. It is recommended to use a value between 1 and 20. INDPB: float     Represents the individual probability of mutation for each attribute of the individual. It is recommended to use     a value between 0.0 and 0.1. If you have a lot of parameters, you can use a 1/len(parameters) value. CXPB: float     Represents the probability of mating two individuals. It is recommended to use a value between 0.5 and 1.0. NGEN: int     Represents the number of generations. POP_SIZE: int     Represents the size of the population. cost_function_weight: tuple | float = (-1.0,)     The weight of the cost function. The default value is (-1.0,) to minimize the cost function.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>@dataclass\nclass GeneticAlgorithmParameters:\n    \"\"\"The structure used to store the genetic algorithm parameters.\n\n    Can generate the toolbox with default parameters.\n    parameters.\n\n    Parameters\n    ----------\n    MUTPB: float\n        Represents the probability of mutating an individual. It is recommended to use a value between 0.001 and 0.1.\n    ETA: float\n        Crowding degree of the mutation. A high eta will produce a mutant resembling its parent, while a small eta will\n        produce a solution much more different. It is recommended to use a value between 1 and 20.\n    INDPB: float\n        Represents the individual probability of mutation for each attribute of the individual. It is recommended to use\n        a value between 0.0 and 0.1. If you have a lot of parameters, you can use a 1/len(parameters) value.\n    CXPB: float\n        Represents the probability of mating two individuals. It is recommended to use a value between 0.5 and 1.0.\n    NGEN: int\n        Represents the number of generations.\n    POP_SIZE: int\n        Represents the size of the population.\n    cost_function_weight: tuple | float = (-1.0,)\n        The weight of the cost function. The default value is (-1.0,) to minimize the cost function.\n\n    \"\"\"\n\n    ETA: float\n    INDPB: float\n    CXPB: float\n    MUTPB: float\n    NGEN: int\n    POP_SIZE: int\n    TOURNSIZE: int = field(default=3)\n    cost_function_weight: tuple[Number] = (-1.0,)\n\n    def __post_init__(self: GeneticAlgorithmParameters) -&gt; None:\n        \"\"\"Check parameters and set default functions for selection, mating, mutation and variation.\"\"\"\n        self.select = tools.selTournament\n        self.mate = tools.cxTwoPoint  # NOTE(Jules): We should test this method `tools.cxSimulatedBinary``\n        self.mutate = tools.mutPolynomialBounded\n        self.variation = algorithms.varAnd\n        self.cost_function_weight = tuple(\n            np.asarray(self.cost_function_weight) / np.sum(np.absolute(self.cost_function_weight))\n        )\n\n    def generate_toolbox(self: GeneticAlgorithmParameters, parameters: Sequence[Parameter]) -&gt; base.Toolbox:\n        \"\"\"Generate a DEAP toolbox with the necessary functions for the genetic algorithm.\"\"\"\n        toolbox = base.Toolbox()\n        Individual = individual_creator(self.cost_function_weight)  # noqa: N806\n        toolbox.register(\"Individual\", Individual)\n\n        for param in parameters:\n            toolbox.register(param.name, param.init_method, param.lower_bound, param.upper_bound)\n\n        def individual() -&gt; list:\n            return Individual([param.init_method(param.lower_bound, param.upper_bound) for param in parameters])\n\n        toolbox.register(\"population\", tools.initRepeat, list, individual)\n        # Note: Evaluation is now handled by evaluation strategies, not the toolbox\n        toolbox.register(\"mate\", self.mate)\n        low_boundaries = [param.lower_bound for param in parameters]\n        up_boundaries = [param.upper_bound for param in parameters]\n        toolbox.register(\"mutate\", self.mutate, eta=self.ETA, indpb=self.INDPB, low=low_boundaries, up=up_boundaries)\n        toolbox.register(\"select\", self.select, tournsize=self.TOURNSIZE)\n        return toolbox\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithmParameters.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check parameters and set default functions for selection, mating, mutation and variation.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>def __post_init__(self: GeneticAlgorithmParameters) -&gt; None:\n    \"\"\"Check parameters and set default functions for selection, mating, mutation and variation.\"\"\"\n    self.select = tools.selTournament\n    self.mate = tools.cxTwoPoint  # NOTE(Jules): We should test this method `tools.cxSimulatedBinary``\n    self.mutate = tools.mutPolynomialBounded\n    self.variation = algorithms.varAnd\n    self.cost_function_weight = tuple(\n        np.asarray(self.cost_function_weight) / np.sum(np.absolute(self.cost_function_weight))\n    )\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithmParameters.generate_toolbox","title":"<code>generate_toolbox(parameters)</code>","text":"<p>Generate a DEAP toolbox with the necessary functions for the genetic algorithm.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>def generate_toolbox(self: GeneticAlgorithmParameters, parameters: Sequence[Parameter]) -&gt; base.Toolbox:\n    \"\"\"Generate a DEAP toolbox with the necessary functions for the genetic algorithm.\"\"\"\n    toolbox = base.Toolbox()\n    Individual = individual_creator(self.cost_function_weight)  # noqa: N806\n    toolbox.register(\"Individual\", Individual)\n\n    for param in parameters:\n        toolbox.register(param.name, param.init_method, param.lower_bound, param.upper_bound)\n\n    def individual() -&gt; list:\n        return Individual([param.init_method(param.lower_bound, param.upper_bound) for param in parameters])\n\n    toolbox.register(\"population\", tools.initRepeat, list, individual)\n    # Note: Evaluation is now handled by evaluation strategies, not the toolbox\n    toolbox.register(\"mate\", self.mate)\n    low_boundaries = [param.lower_bound for param in parameters]\n    up_boundaries = [param.upper_bound for param in parameters]\n    toolbox.register(\"mutate\", self.mutate, eta=self.ETA, indpb=self.INDPB, low=low_boundaries, up=up_boundaries)\n    toolbox.register(\"select\", self.select, tournsize=self.TOURNSIZE)\n    return toolbox\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm","title":"<code>GeneticAlgorithm</code>  <code>dataclass</code>","text":"<p>Genetic algorithm for optimizing SeapoPym models.</p> <p>By default, the process order is SCM: Select, Cross, Mutate.</p> <p>Uses the Strategy pattern for individual evaluation, allowing easy switching between sequential and hybrid modes as needed.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm--examples","title":"Examples","text":"<p>from seapopym_optimization.algorithm.genetic_algorithm import GeneticAlgorithmFactory ga = GeneticAlgorithmFactory.create_sequential(meta_params, cost_function) results = ga.optimize()</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm--attributes","title":"Attributes","text":"<p>meta_parameter: GeneticAlgorithmParameters     The parameters of the genetic algorithm. cost_function: CostFunctionProtocol     The cost function to optimize. evaluation_strategy: AbstractEvaluationStrategy     Strategy pattern for evaluating individuals. constraint: Sequence[ConstraintProtocol] | None     The constraints to apply to the individuals. If None, no constraints are applied. save: PathLike | None     The path to save the logbook (in Parquet format). If None, the logbook is not saved.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>@dataclass\nclass GeneticAlgorithm:\n    \"\"\"Genetic algorithm for optimizing SeapoPym models.\n\n    By default, the process order is SCM: Select, Cross, Mutate.\n\n    Uses the Strategy pattern for individual evaluation, allowing\n    easy switching between sequential and hybrid modes as needed.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from seapopym_optimization.algorithm.genetic_algorithm import GeneticAlgorithmFactory\n    &gt;&gt;&gt; ga = GeneticAlgorithmFactory.create_sequential(meta_params, cost_function)\n    &gt;&gt;&gt; results = ga.optimize()\n\n    Attributes\n    ----------\n    meta_parameter: GeneticAlgorithmParameters\n        The parameters of the genetic algorithm.\n    cost_function: CostFunctionProtocol\n        The cost function to optimize.\n    evaluation_strategy: AbstractEvaluationStrategy\n        Strategy pattern for evaluating individuals.\n    constraint: Sequence[ConstraintProtocol] | None\n        The constraints to apply to the individuals. If None, no constraints are applied.\n    save: PathLike | None\n        The path to save the logbook (in Parquet format). If None, the logbook is not saved.\n\n    \"\"\"\n\n    meta_parameter: GeneticAlgorithmParameters\n    cost_function: CostFunctionProtocol\n    evaluation_strategy: AbstractEvaluationStrategy\n    constraint: Sequence[ConstraintProtocol] | None = None\n\n    save: FilePath | WriteBuffer[bytes] | None = None\n    logbook: Logbook | None = field(default=None, repr=False)\n    toolbox: base.Toolbox | None = field(default=None, init=False, repr=False)\n\n    def __post_init__(self: GeneticAlgorithm) -&gt; None:\n        \"\"\"Check parameters and initialize the evaluation strategy.\"\"\"\n        # Logbook configuration\n        if self.logbook is not None and not isinstance(self.logbook, Logbook):\n            self.logbook = Logbook(self.logbook)\n        if self.save is not None:\n            self.save = Path(self.save)\n            if self.save.exists():\n                warning_msg = f\"Logbook file {self.save} already exists. It will be overwritten.\"\n                logger.warning(warning_msg)\n\n        # Toolbox generation\n        ordered_parameters = self.cost_function.functional_groups.unique_functional_groups_parameters_ordered()\n        self.toolbox = self.meta_parameter.generate_toolbox(ordered_parameters.values())\n\n        # Application des contraintes\n        if self.constraint is not None:\n            for constraint in self.constraint:\n                self.toolbox.decorate(\"evaluate\", constraint.generate(list(ordered_parameters.keys())))\n\n        # Validation des poids\n        if len(self.meta_parameter.cost_function_weight) != len(self.cost_function.observations):\n            msg = (\n                \"The cost function weight must have the same length as the number of observations. \"\n                f\"Got {len(self.meta_parameter.cost_function_weight)} and {len(self.cost_function.observations)}.\"\n            )\n            raise ValueError(msg)\n\n    def update_logbook(self: GeneticAlgorithm, logbook: Logbook) -&gt; None:\n        \"\"\"Update the logbook with the new data and save to disk if a path is provided.\"\"\"\n        if not isinstance(logbook, Logbook):\n            logbook = Logbook(logbook)\n\n        if self.logbook is None:\n            self.logbook = logbook\n        else:\n            # Append new generation using Pandas concat\n            self.logbook = self.logbook.append_new_generation(logbook)\n\n        if self.save is not None:\n            self.logbook.to_parquet(self.save)\n\n    def _evaluate(self: GeneticAlgorithm, individuals: Sequence, generation: int) -&gt; Logbook:\n        \"\"\"Evaluate individuals by delegating to the evaluation strategy.\n\n        Creates and returns a Logbook for the current generation.\n        \"\"\"\n\n        def update_fitness(individuals: list) -&gt; list:\n            known = [ind.fitness.valid for ind in individuals]\n            invalid_ind = [ind for ind in individuals if not ind.fitness.valid]\n\n            if invalid_ind:\n                # Delegation to the evaluation strategy\n                fitnesses = self.evaluation_strategy.evaluate(invalid_ind)\n\n                for ind, fit in zip(invalid_ind, fitnesses, strict=True):\n                    ind.fitness.values = fit\n\n            return known\n\n        known = update_fitness(individuals)\n\n        # Extract parameter names and fitness names\n        parameter_names = list(\n            self.cost_function.functional_groups.unique_functional_groups_parameters_ordered().keys()\n        )\n        fitness_names = list(self.cost_function.observations.keys())\n\n        # Create Logbook from individuals (fitness is automatically extracted)\n        return Logbook.from_individual(\n            generation=generation,\n            is_from_previous_generation=known,\n            individual=individuals,\n            parameter_names=parameter_names,\n            fitness_names=fitness_names,\n        )\n\n    def _initialization(self: GeneticAlgorithm) -&gt; tuple[int, list[list]]:\n        \"\"\"Initialize the genetic algorithm. If a logbook is provided, it will load the last generation.\"\"\"\n\n        def create_first_generation() -&gt; tuple[Literal[1], list[list]]:\n            \"\"\"Create the first generation (i.e. generation `0`) of individuals.\"\"\"\n            new_generation = 0\n            population = self.toolbox.population(n=self.meta_parameter.POP_SIZE)\n            logbook = self._evaluate(individuals=population, generation=new_generation)\n            self.update_logbook(logbook)\n            next_generation = new_generation + 1\n            return next_generation, population\n\n        def create_population_from_logbook(population_unprocessed: pd.DataFrame) -&gt; list[list]:\n            \"\"\"Create a population from the logbook DataFrame.\"\"\"\n            individuals = population_unprocessed.loc[:, [LogbookCategory.PARAMETER]].to_numpy()\n            fitness = list(population_unprocessed.loc[:, [LogbookCategory.FITNESS]].itertuples(index=False, name=None))\n            fitness = [() if any(np.isnan(fit)) else fit for fit in fitness]\n            return [\n                self.toolbox.Individual(iterator=iterator, values=values)\n                for iterator, values in zip(individuals, fitness, strict=True)\n            ]\n\n        if self.logbook is None:\n            return create_first_generation()\n\n        logger.info(\"Logbook found. Loading last generation.\")\n\n        last_computed_generation = self.logbook.index.get_level_values(LogbookIndex.GENERATION).max()\n        population_unprocessed = self.logbook.loc[last_computed_generation]\n\n        population = create_population_from_logbook(population_unprocessed)\n\n        if population_unprocessed.loc[:, LogbookCategory.FITNESS].isna().any(axis=None):\n            logger.warning(\"Some individuals in the logbook have no fitness values. Re-evaluating the population.\")\n            logbook = self._evaluate(population, last_computed_generation)\n            self.logbook = None\n            self.update_logbook(logbook)\n\n        return last_computed_generation + 1, population\n\n    def optimize(self: GeneticAlgorithm) -&gt; Logbook:\n        \"\"\"This is the main function. Use it to optimize your model.\"\"\"\n        generation_start, population = self._initialization()\n\n        for gen in range(generation_start, self.meta_parameter.NGEN):\n            log_message = f\"Generation {gen} / {self.meta_parameter.NGEN}.\"\n            logger.info(log_message)\n            offspring = self.toolbox.select(population, self.meta_parameter.POP_SIZE)\n            offspring = self.meta_parameter.variation(\n                offspring, self.toolbox, self.meta_parameter.CXPB, self.meta_parameter.MUTPB\n            )\n            logbook = self._evaluate(offspring, gen)\n\n            self.update_logbook(logbook)\n            population[:] = offspring\n\n        return self.logbook.copy()\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check parameters and initialize the evaluation strategy.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>def __post_init__(self: GeneticAlgorithm) -&gt; None:\n    \"\"\"Check parameters and initialize the evaluation strategy.\"\"\"\n    # Logbook configuration\n    if self.logbook is not None and not isinstance(self.logbook, Logbook):\n        self.logbook = Logbook(self.logbook)\n    if self.save is not None:\n        self.save = Path(self.save)\n        if self.save.exists():\n            warning_msg = f\"Logbook file {self.save} already exists. It will be overwritten.\"\n            logger.warning(warning_msg)\n\n    # Toolbox generation\n    ordered_parameters = self.cost_function.functional_groups.unique_functional_groups_parameters_ordered()\n    self.toolbox = self.meta_parameter.generate_toolbox(ordered_parameters.values())\n\n    # Application des contraintes\n    if self.constraint is not None:\n        for constraint in self.constraint:\n            self.toolbox.decorate(\"evaluate\", constraint.generate(list(ordered_parameters.keys())))\n\n    # Validation des poids\n    if len(self.meta_parameter.cost_function_weight) != len(self.cost_function.observations):\n        msg = (\n            \"The cost function weight must have the same length as the number of observations. \"\n            f\"Got {len(self.meta_parameter.cost_function_weight)} and {len(self.cost_function.observations)}.\"\n        )\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm.update_logbook","title":"<code>update_logbook(logbook)</code>","text":"<p>Update the logbook with the new data and save to disk if a path is provided.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>def update_logbook(self: GeneticAlgorithm, logbook: Logbook) -&gt; None:\n    \"\"\"Update the logbook with the new data and save to disk if a path is provided.\"\"\"\n    if not isinstance(logbook, Logbook):\n        logbook = Logbook(logbook)\n\n    if self.logbook is None:\n        self.logbook = logbook\n    else:\n        # Append new generation using Pandas concat\n        self.logbook = self.logbook.append_new_generation(logbook)\n\n    if self.save is not None:\n        self.logbook.to_parquet(self.save)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm.optimize","title":"<code>optimize()</code>","text":"<p>This is the main function. Use it to optimize your model.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>def optimize(self: GeneticAlgorithm) -&gt; Logbook:\n    \"\"\"This is the main function. Use it to optimize your model.\"\"\"\n    generation_start, population = self._initialization()\n\n    for gen in range(generation_start, self.meta_parameter.NGEN):\n        log_message = f\"Generation {gen} / {self.meta_parameter.NGEN}.\"\n        logger.info(log_message)\n        offspring = self.toolbox.select(population, self.meta_parameter.POP_SIZE)\n        offspring = self.meta_parameter.variation(\n            offspring, self.toolbox, self.meta_parameter.CXPB, self.meta_parameter.MUTPB\n        )\n        logbook = self._evaluate(offspring, gen)\n\n        self.update_logbook(logbook)\n        population[:] = offspring\n\n    return self.logbook.copy()\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.individual_creator","title":"<code>individual_creator(cost_function_weight)</code>","text":"<p>Create a custom individual class for DEAP genetic algorithms.</p> <p>This individual class inherits from <code>list</code> and includes a fitness attribute. It is redefined to work with the Dask framework, which does not support the default DEAP individual structure created with <code>deap.creator.create</code>.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/genetic_algorithm.py</code> <pre><code>def individual_creator(cost_function_weight: tuple[Number]) -&gt; type:\n    \"\"\"Create a custom individual class for DEAP genetic algorithms.\n\n    This individual class inherits from `list` and includes a fitness attribute. It is redefined to work with the\n    Dask framework, which does not support the default DEAP individual structure created with `deap.creator.create`.\n    \"\"\"\n\n    class Fitness(base.Fitness):\n        \"\"\"Fitness class to store the fitness of an individual.\"\"\"\n\n        weights = cost_function_weight\n\n    class Individual(list):\n        \"\"\"Individual class to store the parameters of an individual.\"\"\"\n\n        def __init__(self: Individual, iterator: Sequence, values: Sequence[Number] = ()) -&gt; None:\n            super().__init__(iterator)\n            self.fitness = Fitness(values=values)\n\n    return Individual\n</code></pre>"},{"location":"api/seapopym-optimization/#factory","title":"Factory","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory","title":"<code>seapopym_optimization.algorithm.genetic_algorithm.factory</code>","text":"<p>Factory for creating configured GeneticAlgorithm instances.</p> <p>This module provides factory methods to simplify the creation of GeneticAlgorithm instances with different evaluation strategies, hiding configuration complexity for business users.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory","title":"<code>GeneticAlgorithmFactory</code>","text":"<p>Factory for creating GeneticAlgorithm instances with different configurations.</p> <p>This factory simplifies genetic algorithm creation by encapsulating the configuration logic for evaluation strategies and distribution.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory--see-also","title":"See Also","text":"<p>seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm : Main GA class</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/factory.py</code> <pre><code>class GeneticAlgorithmFactory:\n    \"\"\"Factory for creating GeneticAlgorithm instances with different configurations.\n\n    This factory simplifies genetic algorithm creation by encapsulating\n    the configuration logic for evaluation strategies and distribution.\n\n    See Also\n    --------\n    seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm.GeneticAlgorithm : Main GA class\n\n    \"\"\"\n\n    @staticmethod\n    def create_sequential(\n        meta_parameter: GeneticAlgorithmParameters, cost_function: CostFunctionProtocol, **kwargs: Any\n    ) -&gt; GeneticAlgorithm:\n        \"\"\"Create a GA in sequential mode.\n\n        Simplest evaluation mode, suitable for small populations\n        or situations where parallelization is not necessary.\n\n        Parameters\n        ----------\n        meta_parameter : GeneticAlgorithmParameters\n            Genetic algorithm parameters\n        cost_function : CostFunctionProtocol\n            Cost function to optimize\n        **kwargs\n            Additional arguments for GeneticAlgorithm\n\n        Returns\n        -------\n        GeneticAlgorithm\n            Instance configured in sequential mode\n\n        Examples\n        --------\n        &gt;&gt;&gt; ga = GeneticAlgorithmFactory.create_sequential(meta_params, cost_function)\n        &gt;&gt;&gt; results = ga.optimize()\n\n        \"\"\"\n        logger.info(\"Creating genetic algorithm in sequential mode\")\n\n        return GeneticAlgorithm(\n            meta_parameter=meta_parameter,\n            cost_function=cost_function,\n            evaluation_strategy=SequentialEvaluation(cost_function),\n            **kwargs,\n        )\n\n    @staticmethod\n    def create_parallel(\n        meta_parameter: GeneticAlgorithmParameters, cost_function: CostFunctionProtocol, n_jobs: int = -1, **kwargs: Any\n    ) -&gt; GeneticAlgorithm:\n        \"\"\"Create a GA in parallel mode using multiprocessing.\n\n        Uses ProcessPoolExecutor to evaluate individuals across\n        multiple CPU cores for improved performance.\n\n        Parameters\n        ----------\n        meta_parameter : GeneticAlgorithmParameters\n            Genetic algorithm parameters\n        cost_function : CostFunctionProtocol\n            Cost function to optimize\n        n_jobs : int, default=-1\n            Number of parallel jobs. If -1, use all available CPUs\n        **kwargs\n            Additional arguments for GeneticAlgorithm\n\n        Returns\n        -------\n        GeneticAlgorithm\n            Instance configured in parallel mode\n\n        Examples\n        --------\n        &gt;&gt;&gt; ga = GeneticAlgorithmFactory.create_parallel(meta_params, cost_function, n_jobs=4)\n        &gt;&gt;&gt; results = ga.optimize()\n\n        \"\"\"\n        logger.info(\"Creating genetic algorithm in parallel mode with %d jobs\", n_jobs)\n\n        return GeneticAlgorithm(\n            meta_parameter=meta_parameter,\n            cost_function=cost_function,\n            evaluation_strategy=ParallelEvaluation(cost_function, n_jobs=n_jobs),\n            **kwargs,\n        )\n\n    @staticmethod\n    def create_distributed(\n        meta_parameter: GeneticAlgorithmParameters,\n        cost_function: CostFunctionProtocol,\n        client: Client,\n        **kwargs: Any,\n    ) -&gt; GeneticAlgorithm:\n        \"\"\"Create a GA in distributed mode with Dask.\n\n        Automatically detects if data is already distributed (Futures) and distributes\n        if necessary. Uses Dask client.map() with distributed data to evaluate\n        individuals across multiple workers efficiently.\n\n        WARNING: This method modifies the cost_function in-place by replacing\n        forcing and observations data with Dask Futures.\n\n        Parameters\n        ----------\n        meta_parameter : GeneticAlgorithmParameters\n            Genetic algorithm parameters\n        cost_function : CostFunctionProtocol\n            Cost function to optimize (will be modified in-place)\n        client : Client\n            Dask client for distributed computing\n        **kwargs\n            Additional arguments for GeneticAlgorithm\n\n        Returns\n        -------\n        GeneticAlgorithm\n            GA instance configured for distributed execution\n\n        Raises\n        ------\n        TypeError\n            If client is not a Dask Client instance\n\n        Examples\n        --------\n        &gt;&gt;&gt; from dask.distributed import Client\n        &gt;&gt;&gt; client = Client()\n        &gt;&gt;&gt; ga = GeneticAlgorithmFactory.create_distributed(\n        ...     meta_params, cost_function, client\n        ... )\n        &gt;&gt;&gt; results = ga.optimize()\n        &gt;&gt;&gt; client.close()\n\n        \"\"\"\n        if not isinstance(client, Client):\n            msg = \"client must be a dask.distributed.Client instance\"\n            raise TypeError(msg)\n\n        logger.info(\"Creating genetic algorithm in distributed mode\")\n\n        # Check forcing and distribute if necessary (modify in-place)\n        if isinstance(cost_function.forcing, Future):\n            logger.info(\"Forcing already distributed (Future detected). Using existing Future.\")\n        else:\n            logger.info(\"Distributing forcing to Dask workers with broadcast=True...\")\n            cost_function.forcing = client.scatter(cost_function.forcing, broadcast=True)\n\n        # Check and distribute observations dict (modify in-place)\n        for name, obs in cost_function.observations.items():\n            if isinstance(obs, Future):\n                logger.info(\"Observation '%s' already distributed (Future detected). Using existing Future.\", name)\n            else:\n                logger.info(\"Distributing observation '%s' to Dask workers with broadcast=True...\", name)\n                # Distribute the entire observation object\n                cost_function.observations[name] = client.scatter(obs, broadcast=True)\n\n        # Create distributed evaluation strategy with explicit client\n        evaluation_strategy = DistributedEvaluation(cost_function, client)\n\n        # Create and return GA instance\n        return GeneticAlgorithm(\n            meta_parameter=meta_parameter,\n            cost_function=cost_function,\n            evaluation_strategy=evaluation_strategy,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_sequential","title":"<code>create_sequential(meta_parameter, cost_function, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a GA in sequential mode.</p> <p>Simplest evaluation mode, suitable for small populations or situations where parallelization is not necessary.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_sequential--parameters","title":"Parameters","text":"<p>meta_parameter : GeneticAlgorithmParameters     Genetic algorithm parameters cost_function : CostFunctionProtocol     Cost function to optimize **kwargs     Additional arguments for GeneticAlgorithm</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_sequential--returns","title":"Returns","text":"<p>GeneticAlgorithm     Instance configured in sequential mode</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_sequential--examples","title":"Examples","text":"<p>ga = GeneticAlgorithmFactory.create_sequential(meta_params, cost_function) results = ga.optimize()</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/factory.py</code> <pre><code>@staticmethod\ndef create_sequential(\n    meta_parameter: GeneticAlgorithmParameters, cost_function: CostFunctionProtocol, **kwargs: Any\n) -&gt; GeneticAlgorithm:\n    \"\"\"Create a GA in sequential mode.\n\n    Simplest evaluation mode, suitable for small populations\n    or situations where parallelization is not necessary.\n\n    Parameters\n    ----------\n    meta_parameter : GeneticAlgorithmParameters\n        Genetic algorithm parameters\n    cost_function : CostFunctionProtocol\n        Cost function to optimize\n    **kwargs\n        Additional arguments for GeneticAlgorithm\n\n    Returns\n    -------\n    GeneticAlgorithm\n        Instance configured in sequential mode\n\n    Examples\n    --------\n    &gt;&gt;&gt; ga = GeneticAlgorithmFactory.create_sequential(meta_params, cost_function)\n    &gt;&gt;&gt; results = ga.optimize()\n\n    \"\"\"\n    logger.info(\"Creating genetic algorithm in sequential mode\")\n\n    return GeneticAlgorithm(\n        meta_parameter=meta_parameter,\n        cost_function=cost_function,\n        evaluation_strategy=SequentialEvaluation(cost_function),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_parallel","title":"<code>create_parallel(meta_parameter, cost_function, n_jobs=-1, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a GA in parallel mode using multiprocessing.</p> <p>Uses ProcessPoolExecutor to evaluate individuals across multiple CPU cores for improved performance.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_parallel--parameters","title":"Parameters","text":"<p>meta_parameter : GeneticAlgorithmParameters     Genetic algorithm parameters cost_function : CostFunctionProtocol     Cost function to optimize n_jobs : int, default=-1     Number of parallel jobs. If -1, use all available CPUs **kwargs     Additional arguments for GeneticAlgorithm</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_parallel--returns","title":"Returns","text":"<p>GeneticAlgorithm     Instance configured in parallel mode</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_parallel--examples","title":"Examples","text":"<p>ga = GeneticAlgorithmFactory.create_parallel(meta_params, cost_function, n_jobs=4) results = ga.optimize()</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/factory.py</code> <pre><code>@staticmethod\ndef create_parallel(\n    meta_parameter: GeneticAlgorithmParameters, cost_function: CostFunctionProtocol, n_jobs: int = -1, **kwargs: Any\n) -&gt; GeneticAlgorithm:\n    \"\"\"Create a GA in parallel mode using multiprocessing.\n\n    Uses ProcessPoolExecutor to evaluate individuals across\n    multiple CPU cores for improved performance.\n\n    Parameters\n    ----------\n    meta_parameter : GeneticAlgorithmParameters\n        Genetic algorithm parameters\n    cost_function : CostFunctionProtocol\n        Cost function to optimize\n    n_jobs : int, default=-1\n        Number of parallel jobs. If -1, use all available CPUs\n    **kwargs\n        Additional arguments for GeneticAlgorithm\n\n    Returns\n    -------\n    GeneticAlgorithm\n        Instance configured in parallel mode\n\n    Examples\n    --------\n    &gt;&gt;&gt; ga = GeneticAlgorithmFactory.create_parallel(meta_params, cost_function, n_jobs=4)\n    &gt;&gt;&gt; results = ga.optimize()\n\n    \"\"\"\n    logger.info(\"Creating genetic algorithm in parallel mode with %d jobs\", n_jobs)\n\n    return GeneticAlgorithm(\n        meta_parameter=meta_parameter,\n        cost_function=cost_function,\n        evaluation_strategy=ParallelEvaluation(cost_function, n_jobs=n_jobs),\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_distributed","title":"<code>create_distributed(meta_parameter, cost_function, client, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a GA in distributed mode with Dask.</p> <p>Automatically detects if data is already distributed (Futures) and distributes if necessary. Uses Dask client.map() with distributed data to evaluate individuals across multiple workers efficiently.</p> <p>WARNING: This method modifies the cost_function in-place by replacing forcing and observations data with Dask Futures.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_distributed--parameters","title":"Parameters","text":"<p>meta_parameter : GeneticAlgorithmParameters     Genetic algorithm parameters cost_function : CostFunctionProtocol     Cost function to optimize (will be modified in-place) client : Client     Dask client for distributed computing **kwargs     Additional arguments for GeneticAlgorithm</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_distributed--returns","title":"Returns","text":"<p>GeneticAlgorithm     GA instance configured for distributed execution</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_distributed--raises","title":"Raises","text":"<p>TypeError     If client is not a Dask Client instance</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.algorithm.genetic_algorithm.factory.GeneticAlgorithmFactory.create_distributed--examples","title":"Examples","text":"<p>from dask.distributed import Client client = Client() ga = GeneticAlgorithmFactory.create_distributed( ...     meta_params, cost_function, client ... ) results = ga.optimize() client.close()</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/algorithm/genetic_algorithm/factory.py</code> <pre><code>@staticmethod\ndef create_distributed(\n    meta_parameter: GeneticAlgorithmParameters,\n    cost_function: CostFunctionProtocol,\n    client: Client,\n    **kwargs: Any,\n) -&gt; GeneticAlgorithm:\n    \"\"\"Create a GA in distributed mode with Dask.\n\n    Automatically detects if data is already distributed (Futures) and distributes\n    if necessary. Uses Dask client.map() with distributed data to evaluate\n    individuals across multiple workers efficiently.\n\n    WARNING: This method modifies the cost_function in-place by replacing\n    forcing and observations data with Dask Futures.\n\n    Parameters\n    ----------\n    meta_parameter : GeneticAlgorithmParameters\n        Genetic algorithm parameters\n    cost_function : CostFunctionProtocol\n        Cost function to optimize (will be modified in-place)\n    client : Client\n        Dask client for distributed computing\n    **kwargs\n        Additional arguments for GeneticAlgorithm\n\n    Returns\n    -------\n    GeneticAlgorithm\n        GA instance configured for distributed execution\n\n    Raises\n    ------\n    TypeError\n        If client is not a Dask Client instance\n\n    Examples\n    --------\n    &gt;&gt;&gt; from dask.distributed import Client\n    &gt;&gt;&gt; client = Client()\n    &gt;&gt;&gt; ga = GeneticAlgorithmFactory.create_distributed(\n    ...     meta_params, cost_function, client\n    ... )\n    &gt;&gt;&gt; results = ga.optimize()\n    &gt;&gt;&gt; client.close()\n\n    \"\"\"\n    if not isinstance(client, Client):\n        msg = \"client must be a dask.distributed.Client instance\"\n        raise TypeError(msg)\n\n    logger.info(\"Creating genetic algorithm in distributed mode\")\n\n    # Check forcing and distribute if necessary (modify in-place)\n    if isinstance(cost_function.forcing, Future):\n        logger.info(\"Forcing already distributed (Future detected). Using existing Future.\")\n    else:\n        logger.info(\"Distributing forcing to Dask workers with broadcast=True...\")\n        cost_function.forcing = client.scatter(cost_function.forcing, broadcast=True)\n\n    # Check and distribute observations dict (modify in-place)\n    for name, obs in cost_function.observations.items():\n        if isinstance(obs, Future):\n            logger.info(\"Observation '%s' already distributed (Future detected). Using existing Future.\", name)\n        else:\n            logger.info(\"Distributing observation '%s' to Dask workers with broadcast=True...\", name)\n            # Distribute the entire observation object\n            cost_function.observations[name] = client.scatter(obs, broadcast=True)\n\n    # Create distributed evaluation strategy with explicit client\n    evaluation_strategy = DistributedEvaluation(cost_function, client)\n\n    # Create and return GA instance\n    return GeneticAlgorithm(\n        meta_parameter=meta_parameter,\n        cost_function=cost_function,\n        evaluation_strategy=evaluation_strategy,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/seapopym-optimization/#functional-groups","title":"Functional Groups","text":""},{"location":"api/seapopym-optimization/#parameters","title":"Parameters","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group","title":"<code>seapopym_optimization.functional_group.base_functional_group</code>","text":"<p>A module that contains the base class for functional groups declaration and parameter management in optimization process.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.Parameter","title":"<code>Parameter</code>  <code>dataclass</code>","text":"<p>The definition of a parameter to optimize.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.Parameter--parameters","title":"Parameters","text":"<p>name: str     The name of the parameter. lower_bound: float     The lower bound of the parameter. upper_bound: float     The upper bound of the parameter. init_method: Callable[[float, float], float], optional     The method used to get the initial value of a parameter. Default is a random uniform distribution that exclude     the bounds values.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>@dataclass\nclass Parameter:\n    \"\"\"The definition of a parameter to optimize.\n\n    Parameters\n    ----------\n    name: str\n        The name of the parameter.\n    lower_bound: float\n        The lower bound of the parameter.\n    upper_bound: float\n        The upper bound of the parameter.\n    init_method: Callable[[float, float], float], optional\n        The method used to get the initial value of a parameter. Default is a random uniform distribution that exclude\n        the bounds values.\n\n    \"\"\"\n\n    name: str\n    lower_bound: float\n    upper_bound: float\n    init_method: Callable[[float, float], float]\n\n    def __post_init__(self: Parameter) -&gt; None:\n        \"\"\"Check that the parameter is correctly defined.\"\"\"\n        if self.lower_bound &gt;= self.upper_bound:\n            msg = f\"Lower bounds ({self.lower_bound}) must be &lt;= to upper bound ({self.upper_bound}).\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.Parameter.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that the parameter is correctly defined.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>def __post_init__(self: Parameter) -&gt; None:\n    \"\"\"Check that the parameter is correctly defined.\"\"\"\n    if self.lower_bound &gt;= self.upper_bound:\n        msg = f\"Lower bounds ({self.lower_bound}) must be &lt;= to upper bound ({self.upper_bound}).\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.AbstractFunctionalGroup","title":"<code>AbstractFunctionalGroup</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The Generic structure used to store the parameters of a functional group as used in SeapoPym.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>@dataclass\nclass AbstractFunctionalGroup(ABC):\n    \"\"\"The Generic structure used to store the parameters of a functional group as used in SeapoPym.\"\"\"\n\n    name: str\n\n    @property\n    def parameters(self: AbstractFunctionalGroup) -&gt; tuple:\n        \"\"\"Return the parameters representing the functional group. Order of declaration is preserved.\"\"\"\n        excluded = (\"name\",)\n        return tuple(getattr(self, field.name) for field in fields(self) if field.name not in excluded)\n\n    def as_dict(self: AbstractFunctionalGroup) -&gt; dict:\n        \"\"\"Return the functional group as a dictionary with parameter names as keys (without functional group name).\"\"\"\n        return {field.name: getattr(self, field.name) for field in fields(self) if field.name != \"name\"}\n\n    def get_parameters_to_optimize(self: AbstractFunctionalGroup) -&gt; Sequence[Parameter]:\n        \"\"\"Return the parameters to optimize as a sequence of `Parameter`.\"\"\"\n        return tuple(param for param in self.parameters if isinstance(param, Parameter))\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.AbstractFunctionalGroup.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>Return the parameters representing the functional group. Order of declaration is preserved.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.AbstractFunctionalGroup.as_dict","title":"<code>as_dict()</code>","text":"<p>Return the functional group as a dictionary with parameter names as keys (without functional group name).</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>def as_dict(self: AbstractFunctionalGroup) -&gt; dict:\n    \"\"\"Return the functional group as a dictionary with parameter names as keys (without functional group name).\"\"\"\n    return {field.name: getattr(self, field.name) for field in fields(self) if field.name != \"name\"}\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.AbstractFunctionalGroup.get_parameters_to_optimize","title":"<code>get_parameters_to_optimize()</code>","text":"<p>Return the parameters to optimize as a sequence of <code>Parameter</code>.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>def get_parameters_to_optimize(self: AbstractFunctionalGroup) -&gt; Sequence[Parameter]:\n    \"\"\"Return the parameters to optimize as a sequence of `Parameter`.\"\"\"\n    return tuple(param for param in self.parameters if isinstance(param, Parameter))\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.FunctionalGroupSet","title":"<code>FunctionalGroupSet</code>  <code>dataclass</code>","text":"<p>The structure used to generate the matrix of all parameters for all functional groups.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>@dataclass\nclass FunctionalGroupSet[T: AbstractFunctionalGroup]:\n    \"\"\"The structure used to generate the matrix of all parameters for all functional groups.\"\"\"\n\n    functional_groups: Sequence[T]\n\n    def __post_init__(self: FunctionalGroupSet) -&gt; None:\n        \"\"\"Check that the functional groups are correctly typed.\"\"\"\n        if not all(isinstance(group, AbstractFunctionalGroup) for group in self.functional_groups):\n            msg = \"All functional groups must be instances of AbstractFunctionalGroup.\"\n            raise TypeError(msg)\n\n    def functional_groups_name(self: FunctionalGroupSet) -&gt; Sequence[str]:\n        \"\"\"Return the ordered list of the functional groups name.\"\"\"\n        return tuple(group.name for group in self.functional_groups)\n\n    def unique_functional_groups_parameters_ordered(self: FunctionalGroupSet) -&gt; dict[str, Parameter]:\n        \"\"\"Return the unique optimized parameters of all functional groups in the order of declaration.\n\n        Used to setup toolbox for optimization algorithms.\n        \"\"\"\n        all_param = tuple(chain.from_iterable(group.get_parameters_to_optimize() for group in self.functional_groups))\n        unique_params = {}\n        for param in all_param:\n            if param.name not in unique_params:\n                unique_params[param.name] = param\n        return unique_params\n\n    def generate(self: FunctionalGroupSet, x: Sequence[float]) -&gt; list[T]:\n        \"\"\"Generate a list of dictionaries representing the functional groups with their parameters values.\n\n        The order of the parameters is defined by the `unique_functional_groups_parameters_ordered` method.\n        The input `x` should match the order of the parameters returned by that method.\n        It is used by the `configuration_generator` to generate the model.\n\n        Parameters\n        ----------\n        x: Sequence[float]\n            A sequence of float values representing the parameters to set for each functional group.\n\n        Returns\n        -------\n        list[AbstractFunctionalGroup]\n            A list of functional groups with their parameters and their corresponding values.\n\n        \"\"\"\n        keys = list(self.unique_functional_groups_parameters_ordered().keys())\n\n        try:\n            parameters_values = dict(zip(keys, x, strict=True))\n        except ValueError as e:\n            msg = (\n                f\"Cost function parameters {x} do not match the expected parameters {keys}. \"\n                \"Please check your parameters definition.\"\n            )\n            raise ValueError(msg) from e\n\n        result = []\n        for group in self.functional_groups:\n            param_names = list(group.as_dict().keys())\n            param_values = [\n                parameters_values.get(param.name, np.nan) if isinstance(param, Parameter) else param\n                for param in group.parameters\n            ]\n            # Create dictionary with updated parameter values and preserve the name\n            group_dict = dict(zip(param_names, param_values, strict=True))\n            group_dict[\"name\"] = group.name\n            # Use type(group) instead of T to instantiate the concrete class\n            result.append(type(group)(**group_dict))\n        return result\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.FunctionalGroupSet.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that the functional groups are correctly typed.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>def __post_init__(self: FunctionalGroupSet) -&gt; None:\n    \"\"\"Check that the functional groups are correctly typed.\"\"\"\n    if not all(isinstance(group, AbstractFunctionalGroup) for group in self.functional_groups):\n        msg = \"All functional groups must be instances of AbstractFunctionalGroup.\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.FunctionalGroupSet.functional_groups_name","title":"<code>functional_groups_name()</code>","text":"<p>Return the ordered list of the functional groups name.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>def functional_groups_name(self: FunctionalGroupSet) -&gt; Sequence[str]:\n    \"\"\"Return the ordered list of the functional groups name.\"\"\"\n    return tuple(group.name for group in self.functional_groups)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.FunctionalGroupSet.unique_functional_groups_parameters_ordered","title":"<code>unique_functional_groups_parameters_ordered()</code>","text":"<p>Return the unique optimized parameters of all functional groups in the order of declaration.</p> <p>Used to setup toolbox for optimization algorithms.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>def unique_functional_groups_parameters_ordered(self: FunctionalGroupSet) -&gt; dict[str, Parameter]:\n    \"\"\"Return the unique optimized parameters of all functional groups in the order of declaration.\n\n    Used to setup toolbox for optimization algorithms.\n    \"\"\"\n    all_param = tuple(chain.from_iterable(group.get_parameters_to_optimize() for group in self.functional_groups))\n    unique_params = {}\n    for param in all_param:\n        if param.name not in unique_params:\n            unique_params[param.name] = param\n    return unique_params\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.FunctionalGroupSet.generate","title":"<code>generate(x)</code>","text":"<p>Generate a list of dictionaries representing the functional groups with their parameters values.</p> <p>The order of the parameters is defined by the <code>unique_functional_groups_parameters_ordered</code> method. The input <code>x</code> should match the order of the parameters returned by that method. It is used by the <code>configuration_generator</code> to generate the model.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.FunctionalGroupSet.generate--parameters","title":"Parameters","text":"<p>x: Sequence[float]     A sequence of float values representing the parameters to set for each functional group.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.base_functional_group.FunctionalGroupSet.generate--returns","title":"Returns","text":"<p>list[AbstractFunctionalGroup]     A list of functional groups with their parameters and their corresponding values.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/base_functional_group.py</code> <pre><code>def generate(self: FunctionalGroupSet, x: Sequence[float]) -&gt; list[T]:\n    \"\"\"Generate a list of dictionaries representing the functional groups with their parameters values.\n\n    The order of the parameters is defined by the `unique_functional_groups_parameters_ordered` method.\n    The input `x` should match the order of the parameters returned by that method.\n    It is used by the `configuration_generator` to generate the model.\n\n    Parameters\n    ----------\n    x: Sequence[float]\n        A sequence of float values representing the parameters to set for each functional group.\n\n    Returns\n    -------\n    list[AbstractFunctionalGroup]\n        A list of functional groups with their parameters and their corresponding values.\n\n    \"\"\"\n    keys = list(self.unique_functional_groups_parameters_ordered().keys())\n\n    try:\n        parameters_values = dict(zip(keys, x, strict=True))\n    except ValueError as e:\n        msg = (\n            f\"Cost function parameters {x} do not match the expected parameters {keys}. \"\n            \"Please check your parameters definition.\"\n        )\n        raise ValueError(msg) from e\n\n    result = []\n    for group in self.functional_groups:\n        param_names = list(group.as_dict().keys())\n        param_values = [\n            parameters_values.get(param.name, np.nan) if isinstance(param, Parameter) else param\n            for param in group.parameters\n        ]\n        # Create dictionary with updated parameter values and preserve the name\n        group_dict = dict(zip(param_names, param_values, strict=True))\n        group_dict[\"name\"] = group.name\n        # Use type(group) instead of T to instantiate the concrete class\n        result.append(type(group)(**group_dict))\n    return result\n</code></pre>"},{"location":"api/seapopym-optimization/#notransport-implementation","title":"NoTransport Implementation","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.no_transport_functional_groups","title":"<code>seapopym_optimization.functional_group.no_transport_functional_groups</code>","text":"<p>This module contains the cost function used to optimize the parameters of the SeapoPym model.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.functional_group.no_transport_functional_groups.NoTransportFunctionalGroup","title":"<code>NoTransportFunctionalGroup</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AbstractFunctionalGroup</code></p> <p>The parameters of a functional group as they are defined in the SeapoPym NoTransport model.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/functional_group/no_transport_functional_groups.py</code> <pre><code>@dataclass\nclass NoTransportFunctionalGroup(AbstractFunctionalGroup):\n    \"\"\"The parameters of a functional group as they are defined in the SeapoPym NoTransport model.\"\"\"\n\n    day_layer: float | Parameter\n    night_layer: float | Parameter\n    energy_transfert: float | Parameter\n    lambda_temperature_0: float | Parameter\n    gamma_lambda_temperature: float | Parameter\n    tr_0: float | Parameter\n    gamma_tr: float | Parameter\n</code></pre>"},{"location":"api/seapopym-optimization/#cost-function","title":"Cost Function","text":""},{"location":"api/seapopym-optimization/#core","title":"Core","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function","title":"<code>seapopym_optimization.cost_function.cost_function</code>","text":"<p>This module contains the cost function used to optimize the parameters of the SeapoPym model.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction","title":"<code>CostFunction</code>  <code>dataclass</code>","text":"<p>The cost function generator for SeapoPym models.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/cost_function.py</code> <pre><code>@dataclass(kw_only=True)\nclass CostFunction:\n    \"\"\"The cost function generator for SeapoPym models.\"\"\"\n\n    # TODO(Jules): We can gather configuration generators and functional groups in a single object later if needed.\n    configuration_generator: ConfigurationGeneratorProtocol\n    functional_groups: FunctionalGroupSet[AbstractFunctionalGroup]\n    forcing: ForcingParameterProtocol\n    kernel: KernelParameterProtocol\n    observations: dict[str, ObservationProtocol] | Sequence[ObservationProtocol]  # Dict or Sequence of observations\n    processor: AbstractScoreProcessor  # Processor for computing scores from state and observations\n\n    def __post_init__(self: CostFunction) -&gt; None:\n        \"\"\"Convert observations to dict if needed and validate observation names match dictionary keys.\"\"\"\n        # Convert Sequence to dict if needed\n        if not isinstance(self.observations, dict):\n            self.observations = {obs.name: obs for obs in self.observations}\n\n        # Validate that observation names match dictionary keys\n        for name, obs in self.observations.items():\n            if obs.name != name:\n                msg = f\"Observation name mismatch: key='{name}', obs.name='{obs.name}'\"\n                raise ValueError(msg)\n\n    # NOTE(Jules): Forcing and observations must be passed as parameter of the cost function to be used with Dask\n    # and scattered to workers. They cannot be attributes of the class.\n    def _cost_function(\n        self: CostFunction,\n        args: np.ndarray,\n        forcing: ForcingParameterProtocol,\n        observations: dict[str, ObservationProtocol],\n    ) -&gt; tuple:\n        \"\"\"Evaluate the cost function for given parameters.\n\n        Parameters\n        ----------\n        args : np.ndarray\n            Individual parameters to evaluate\n        forcing : ForcingParameterProtocol\n            Forcing parameters (resolved from Future if distributed)\n        observations : dict[str, ObservationProtocol]\n            Dictionary of observations (resolved from Futures if distributed)\n\n        Returns\n        -------\n        tuple\n            Fitness values for each observation (in dict order)\n\n        \"\"\"\n        configuration = self.configuration_generator.generate(\n            functional_group_parameters=self.functional_groups.generate(args),\n            forcing_parameters=forcing,\n            kernel=self.kernel,\n        )\n\n        # Create model from configuration and run it\n        with self.configuration_generator.model_class.from_configuration(configuration) as model:\n            model.run()\n            state = model.state\n\n            # Compute score for each observation (dict preserves insertion order in Python 3.7+)\n            return tuple(self.processor.process(state, obs) for obs in observations.values())\n\n    def get_evaluator(self: CostFunction) -&gt; Callable[..., tuple[Number, ...]]:\n        \"\"\"Return the evaluation function to be called on workers.\n\n        This method is used by distributed evaluation strategies to obtain\n        the core evaluation function without captured parameters.\n\n        Returns\n        -------\n        Callable[..., tuple[Number, ...]]\n            Function that takes (args, forcing, observations) and returns a tuple of fitness values\n\n        Examples\n        --------\n        &gt;&gt;&gt; evaluator = cost_function.get_evaluator()\n        &gt;&gt;&gt; fitness = evaluator(args, forcing_data, observations_data)\n\n        \"\"\"\n        return self._cost_function\n\n    def get_distributed_parameters(self: CostFunction) -&gt; dict[str, Any]:\n        \"\"\"Return parameters that should be distributed to workers as a dictionary.\n\n        Dask will automatically resolve any Futures contained in this dictionary\n        when it's passed as an argument to client.map().\n\n        Returns\n        -------\n        dict[str, Any]\n            Dictionary with keys:\n            - 'forcing': ForcingParameter or Future\n            - 'observations': Dict of observations {name: observation} or {name: Future}\n\n        Notes\n        -----\n        If you subclass CostFunction and add new distributed parameters,\n        override this method to include them in the returned dictionary.\n\n        Examples\n        --------\n        &gt;&gt;&gt; params = cost_function.get_distributed_parameters()\n        &gt;&gt;&gt; params['forcing']\n        &lt;ForcingParameter or Future&gt;\n        &gt;&gt;&gt; params['observations']\n        {'Biomass': &lt;TimeSeriesObservation or Future&gt;, ...}\n\n        See Also\n        --------\n        get_evaluator : Get the evaluation function to use with these parameters\n\n        \"\"\"\n        return {\n            \"forcing\": self.forcing,\n            \"observations\": self.observations,\n        }\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Convert observations to dict if needed and validate observation names match dictionary keys.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/cost_function.py</code> <pre><code>def __post_init__(self: CostFunction) -&gt; None:\n    \"\"\"Convert observations to dict if needed and validate observation names match dictionary keys.\"\"\"\n    # Convert Sequence to dict if needed\n    if not isinstance(self.observations, dict):\n        self.observations = {obs.name: obs for obs in self.observations}\n\n    # Validate that observation names match dictionary keys\n    for name, obs in self.observations.items():\n        if obs.name != name:\n            msg = f\"Observation name mismatch: key='{name}', obs.name='{obs.name}'\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_evaluator","title":"<code>get_evaluator()</code>","text":"<p>Return the evaluation function to be called on workers.</p> <p>This method is used by distributed evaluation strategies to obtain the core evaluation function without captured parameters.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_evaluator--returns","title":"Returns","text":"<p>Callable[..., tuple[Number, ...]]     Function that takes (args, forcing, observations) and returns a tuple of fitness values</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_evaluator--examples","title":"Examples","text":"<p>evaluator = cost_function.get_evaluator() fitness = evaluator(args, forcing_data, observations_data)</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/cost_function.py</code> <pre><code>def get_evaluator(self: CostFunction) -&gt; Callable[..., tuple[Number, ...]]:\n    \"\"\"Return the evaluation function to be called on workers.\n\n    This method is used by distributed evaluation strategies to obtain\n    the core evaluation function without captured parameters.\n\n    Returns\n    -------\n    Callable[..., tuple[Number, ...]]\n        Function that takes (args, forcing, observations) and returns a tuple of fitness values\n\n    Examples\n    --------\n    &gt;&gt;&gt; evaluator = cost_function.get_evaluator()\n    &gt;&gt;&gt; fitness = evaluator(args, forcing_data, observations_data)\n\n    \"\"\"\n    return self._cost_function\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_distributed_parameters","title":"<code>get_distributed_parameters()</code>","text":"<p>Return parameters that should be distributed to workers as a dictionary.</p> <p>Dask will automatically resolve any Futures contained in this dictionary when it's passed as an argument to client.map().</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_distributed_parameters--returns","title":"Returns","text":"<p>dict[str, Any]     Dictionary with keys:     - 'forcing': ForcingParameter or Future     - 'observations': Dict of observations {name: observation} or {name: Future}</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_distributed_parameters--notes","title":"Notes","text":"<p>If you subclass CostFunction and add new distributed parameters, override this method to include them in the returned dictionary.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_distributed_parameters--examples","title":"Examples","text":"<p>params = cost_function.get_distributed_parameters() params['forcing']  params['observations']"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.cost_function.CostFunction.get_distributed_parameters--see-also","title":"See Also","text":"<p>get_evaluator : Get the evaluation function to use with these parameters</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/cost_function.py</code> <pre><code>def get_distributed_parameters(self: CostFunction) -&gt; dict[str, Any]:\n    \"\"\"Return parameters that should be distributed to workers as a dictionary.\n\n    Dask will automatically resolve any Futures contained in this dictionary\n    when it's passed as an argument to client.map().\n\n    Returns\n    -------\n    dict[str, Any]\n        Dictionary with keys:\n        - 'forcing': ForcingParameter or Future\n        - 'observations': Dict of observations {name: observation} or {name: Future}\n\n    Notes\n    -----\n    If you subclass CostFunction and add new distributed parameters,\n    override this method to include them in the returned dictionary.\n\n    Examples\n    --------\n    &gt;&gt;&gt; params = cost_function.get_distributed_parameters()\n    &gt;&gt;&gt; params['forcing']\n    &lt;ForcingParameter or Future&gt;\n    &gt;&gt;&gt; params['observations']\n    {'Biomass': &lt;TimeSeriesObservation or Future&gt;, ...}\n\n    See Also\n    --------\n    get_evaluator : Get the evaluation function to use with these parameters\n\n    \"\"\"\n    return {\n        \"forcing\": self.forcing,\n        \"observations\": self.observations,\n    }\n</code></pre>"},{"location":"api/seapopym-optimization/#processors","title":"Processors","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor","title":"<code>seapopym_optimization.cost_function.processor</code>","text":"<p>Observation processing components for cost function evaluation.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.AbstractScoreProcessor","title":"<code>AbstractScoreProcessor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for processing model state and observations to return a score.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>class AbstractScoreProcessor(ABC):\n    \"\"\"Abstract class for processing model state and observations to return a score.\"\"\"\n\n    def __init__(self, comparator: MetricProtocol[xr.DataArray, ObservationProtocol]) -&gt; None:\n        \"\"\"Initialize with a comparator metric.\"\"\"\n        self.comparator = comparator\n\n    @abstractmethod\n    def process(self, state: SeapopymState, observation: ObservationProtocol) -&gt; Number:\n        \"\"\"Process model state and observation to return a score.\"\"\"\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.AbstractScoreProcessor.__init__","title":"<code>__init__(comparator)</code>","text":"<p>Initialize with a comparator metric.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>def __init__(self, comparator: MetricProtocol[xr.DataArray, ObservationProtocol]) -&gt; None:\n    \"\"\"Initialize with a comparator metric.\"\"\"\n    self.comparator = comparator\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.AbstractScoreProcessor.process","title":"<code>process(state, observation)</code>  <code>abstractmethod</code>","text":"<p>Process model state and observation to return a score.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>@abstractmethod\ndef process(self, state: SeapopymState, observation: ObservationProtocol) -&gt; Number:\n    \"\"\"Process model state and observation to return a score.\"\"\"\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.TimeSeriesScoreProcessor","title":"<code>TimeSeriesScoreProcessor</code>","text":"<p>               Bases: <code>AbstractScoreProcessor</code></p> <p>Processes observations in time series format by applying preprocessing and comparison metrics.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>class TimeSeriesScoreProcessor(AbstractScoreProcessor):\n    \"\"\"Processes observations in time series format by applying preprocessing and comparison metrics.\"\"\"\n\n    def __init__(\n        self,\n        comparator: MetricProtocol[xr.DataArray, ObservationProtocol],\n        preprocess: None | Literal[\"resample\", \"interpolate\"] = None,\n    ) -&gt; None:\n        \"\"\"Initialize with a comparator metric.\"\"\"\n        super().__init__(comparator)\n        self.preprocess = preprocess\n\n    def _extract_observation_type(\n        self: TimeSeriesScoreProcessor, state: SeapopymState, observation_type: DayCycle\n    ) -&gt; Sequence[int]:\n        \"\"\"Extract functional group positions based on observation type.\"\"\"\n        if observation_type is DayCycle.DAY:\n            return state[ConfigurationLabels.day_layer]\n        if observation_type is DayCycle.NIGHT:\n            return state[ConfigurationLabels.night_layer]\n        msg = f\"Unknown observation type: {observation_type}\"\n        raise ValueError(msg)\n\n    def _format_prediction(\n        self: TimeSeriesScoreProcessor,\n        prediction: xr.DataArray,\n        observation: TimeSeriesObservation,\n        fg_positions: Sequence[int],\n    ) -&gt; xr.DataArray:\n        \"\"\"Ensure prediction has the correct dimensions.\"\"\"\n        if self.preprocess in [\"resample\", \"interpolate\"]:\n            prediction = prediction.resample({CoordinatesLabels.time: observation.observation_interval}).mean()\n            msg = \"Prediction resampled to match observation interval.\"\n            logger.debug(msg)\n\n        if self.preprocess == \"interpolate\":\n            \"\"\"Interpolate prediction outputs to match observation interval\"\"\"\n            prediction = prediction.interpolate_na(dim=CoordinatesLabels.time)\n            msg = \"Interpolate prediction interval to match observation interval.\"\n            logger.info(msg)\n\n        return prediction.sel(\n            {\n                CoordinatesLabels.functional_group: fg_positions,\n                CoordinatesLabels.time: observation.observation[CoordinatesLabels.time],\n                CoordinatesLabels.X: observation.observation[CoordinatesLabels.X],\n                CoordinatesLabels.Y: observation.observation[CoordinatesLabels.Y],\n            },\n        )\n\n    def _pre_process_prediction(self, state: SeapopymState, observation: TimeSeriesObservation) -&gt; xr.DataArray:\n        \"\"\"Pre-process prediction to match observation dimensions.\"\"\"\n        fg_positions = self._extract_observation_type(state, observation.observation_type)\n        prediction = state[ForcingLabels.biomass]\n        prediction = prediction.pint.quantify().pint.to(observation.observation.units).pint.dequantify()\n        prediction = self._format_prediction(prediction, observation, fg_positions)\n\n        # Sum over functional_group dimension, squeeze size-1 dimensions\n        summed = prediction.sum(CoordinatesLabels.functional_group)\n        return summed.squeeze()\n\n    def process(self, state: SeapopymState, observation: TimeSeriesObservation) -&gt; Number:\n        \"\"\"Compare prediction with observation by applying the comparator. Can pre-process data if needed.\"\"\"\n        prediction = self._pre_process_prediction(state, observation)\n        return self.comparator(prediction, observation.observation)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.TimeSeriesScoreProcessor.__init__","title":"<code>__init__(comparator, preprocess=None)</code>","text":"<p>Initialize with a comparator metric.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>def __init__(\n    self,\n    comparator: MetricProtocol[xr.DataArray, ObservationProtocol],\n    preprocess: None | Literal[\"resample\", \"interpolate\"] = None,\n) -&gt; None:\n    \"\"\"Initialize with a comparator metric.\"\"\"\n    super().__init__(comparator)\n    self.preprocess = preprocess\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.TimeSeriesScoreProcessor.process","title":"<code>process(state, observation)</code>","text":"<p>Compare prediction with observation by applying the comparator. Can pre-process data if needed.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>def process(self, state: SeapopymState, observation: TimeSeriesObservation) -&gt; Number:\n    \"\"\"Compare prediction with observation by applying the comparator. Can pre-process data if needed.\"\"\"\n    prediction = self._pre_process_prediction(state, observation)\n    return self.comparator(prediction, observation.observation)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.LogTimeSeriesScoreProcessor","title":"<code>LogTimeSeriesScoreProcessor</code>","text":"<p>               Bases: <code>TimeSeriesScoreProcessor</code></p> <p>Processes observations in time series format by applying log preprocessing and comparison metrics.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>class LogTimeSeriesScoreProcessor(TimeSeriesScoreProcessor):\n    \"\"\"Processes observations in time series format by applying log preprocessing and comparison metrics.\"\"\"\n\n    \"\"\"Log(1 + biomass) applied to avoid negative values. Observation values must be in mgC/m2.\"\"\"\n\n    def process(self, state: SeapopymState, observation: TimeSeriesObservation) -&gt; Number:\n        \"\"\"Compare log prediction with log observation by applying the comparator. Can pre-process data if needed.\"\"\"\n        prediction = self._pre_process_prediction(state, observation)\n        return self.comparator(xr.ufuncs.log10(1 + prediction), xr.ufuncs.log10(1 + observation.observation))\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.LogTimeSeriesScoreProcessor.process","title":"<code>process(state, observation)</code>","text":"<p>Compare log prediction with log observation by applying the comparator. Can pre-process data if needed.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>def process(self, state: SeapopymState, observation: TimeSeriesObservation) -&gt; Number:\n    \"\"\"Compare log prediction with log observation by applying the comparator. Can pre-process data if needed.\"\"\"\n    prediction = self._pre_process_prediction(state, observation)\n    return self.comparator(xr.ufuncs.log10(1 + prediction), xr.ufuncs.log10(1 + observation.observation))\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.SpatialScoreProcessor","title":"<code>SpatialScoreProcessor</code>","text":"<p>               Bases: <code>AbstractScoreProcessor</code></p> <p>Processes observations in spatial format by applying comparison metrics.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>class SpatialScoreProcessor(AbstractScoreProcessor):\n    \"\"\"Processes observations in spatial format by applying comparison metrics.\"\"\"\n\n    def _extract_observation_type(\n        self: SpatialScoreProcessor, state: SeapopymState, observation_type: DayCycle\n    ) -&gt; Sequence[int]:\n        \"\"\"Extract functional group positions based on observation type.\"\"\"\n        if observation_type is DayCycle.DAY:\n            return state[ConfigurationLabels.day_layer]\n        if observation_type is DayCycle.NIGHT:\n            return state[ConfigurationLabels.night_layer]\n        msg = f\"Unknown observation type: {observation_type}\"\n        raise ValueError(msg)\n\n    def _pre_process_prediction(self, state: SeapopymState, observation: SpatialObservation) -&gt; xr.DataArray:\n        \"\"\"Pre-process prediction to match observation dimensions.\"\"\"\n        fg_positions = self._extract_observation_type(state, observation.observation_type)\n        prediction = state[ForcingLabels.biomass]\n        prediction = prediction.pint.quantify().pint.to(observation.observation.units).pint.dequantify()\n\n        # Select the points corresponding to the observation\n        # We assume observation has coordinates time, X, Y\n        sel_dict = {\n            CoordinatesLabels.functional_group: fg_positions,\n            CoordinatesLabels.time: observation.observation[CoordinatesLabels.time],\n            CoordinatesLabels.X: observation.observation[CoordinatesLabels.X],\n            CoordinatesLabels.Y: observation.observation[CoordinatesLabels.Y],\n        }\n        prediction = prediction.sel(sel_dict, method=\"nearest\")\n\n        # Sum over functional_group dimension, squeeze size-1 dimensions\n        summed = prediction.sum(CoordinatesLabels.functional_group)\n        return summed.squeeze()\n\n    def process(self, state: SeapopymState, observation: SpatialObservation) -&gt; Number:\n        \"\"\"Compare prediction with observation by applying the comparator.\"\"\"\n        prediction = self._pre_process_prediction(state, observation)\n        return self.comparator(prediction, observation.observation)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.SpatialScoreProcessor.process","title":"<code>process(state, observation)</code>","text":"<p>Compare prediction with observation by applying the comparator.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>def process(self, state: SeapopymState, observation: SpatialObservation) -&gt; Number:\n    \"\"\"Compare prediction with observation by applying the comparator.\"\"\"\n    prediction = self._pre_process_prediction(state, observation)\n    return self.comparator(prediction, observation.observation)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.processor.aggregate_biomass_by_layer","title":"<code>aggregate_biomass_by_layer(data, position, name, layer_coordinates, layer_coordinates_name='layer')</code>","text":"<p>Aggregate biomass data by layer coordinates.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/processor.py</code> <pre><code>def aggregate_biomass_by_layer(\n    data: xr.DataArray,\n    position: Sequence[int],\n    name: str,\n    layer_coordinates: Sequence[int],\n    layer_coordinates_name: str = \"layer\",\n) -&gt; xr.DataArray:\n    \"\"\"Aggregate biomass data by layer coordinates.\"\"\"\n    layer_coord = xr.DataArray(\n        np.asarray(position),\n        dims=[CoordinatesLabels.functional_group],\n        coords={CoordinatesLabels.functional_group: data[CoordinatesLabels.functional_group].data},\n        name=layer_coordinates_name,\n        attrs={\"axis\": \"Z\"},\n    )\n    return (\n        data.assign_coords({layer_coordinates_name: layer_coord})\n        .groupby(layer_coordinates_name)\n        .sum(dim=CoordinatesLabels.functional_group)\n        .reindex({layer_coordinates_name: layer_coordinates})\n        .fillna(0)\n        .rename(name)\n    )\n</code></pre>"},{"location":"api/seapopym-optimization/#metrics","title":"Metrics","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric","title":"<code>seapopym_optimization.cost_function.metric</code>","text":"<p>Protocols and implementations for metrics to compare model outputs with observations.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.MetricProtocol","title":"<code>MetricProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for comparing prediction data with observations.</p> <p>All future metric functions should follow this protocol.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/metric.py</code> <pre><code>@runtime_checkable\nclass MetricProtocol[U, V](Protocol):\n    \"\"\"Protocol for comparing prediction data with observations.\n\n    All future metric functions should follow this protocol.\n    \"\"\"\n\n    def __call__(self, prediction: U, observation: V) -&gt; Number:\n        \"\"\"Compare prediction to observation and return a score.\"\"\"\n        ...\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.MetricProtocol.__call__","title":"<code>__call__(prediction, observation)</code>","text":"<p>Compare prediction to observation and return a score.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/metric.py</code> <pre><code>def __call__(self, prediction: U, observation: V) -&gt; Number:\n    \"\"\"Compare prediction to observation and return a score.\"\"\"\n    ...\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.rmse_comparator","title":"<code>rmse_comparator(prediction, observation)</code>","text":"<p>Calculate Root Mean Square Error (RMSE) between prediction and observation.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.rmse_comparator--parameters","title":"Parameters","text":"<p>prediction : ArrayLike     Predicted values. observation : ArrayLike     Observed values.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.rmse_comparator--returns","title":"Returns","text":"<p>Number     RMSE value.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/metric.py</code> <pre><code>def rmse_comparator(prediction: ArrayLike, observation: ArrayLike) -&gt; Number:\n    \"\"\"Calculate Root Mean Square Error (RMSE) between prediction and observation.\n\n    Parameters\n    ----------\n    prediction : ArrayLike\n        Predicted values.\n    observation : ArrayLike\n        Observed values.\n\n    Returns\n    -------\n    Number\n        RMSE value.\n\n    \"\"\"\n    return np.sqrt(np.mean((prediction - observation) ** 2))\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.nrmse_std_comparator","title":"<code>nrmse_std_comparator(prediction, observation)</code>","text":"<p>Calculate Normalized RMSE (by standard deviation) between prediction and observation.</p> <p>The RMSE is divided by the standard deviation of the observation to provide a scale-invariant error metric.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.nrmse_std_comparator--parameters","title":"Parameters","text":"<p>prediction : ArrayLike     Predicted values. observation : ArrayLike     Observed values.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.cost_function.metric.nrmse_std_comparator--returns","title":"Returns","text":"<p>Number     Normalized RMSE value.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/cost_function/metric.py</code> <pre><code>def nrmse_std_comparator(prediction: ArrayLike, observation: ArrayLike) -&gt; Number:\n    \"\"\"Calculate Normalized RMSE (by standard deviation) between prediction and observation.\n\n    The RMSE is divided by the standard deviation of the observation to provide a scale-invariant\n    error metric.\n\n    Parameters\n    ----------\n    prediction : ArrayLike\n        Predicted values.\n    observation : ArrayLike\n        Observed values.\n\n    Returns\n    -------\n    Number\n        Normalized RMSE value.\n\n    \"\"\"\n    return rmse_comparator(prediction, observation) / observation.std()\n</code></pre>"},{"location":"api/seapopym-optimization/#observations","title":"Observations","text":""},{"location":"api/seapopym-optimization/#base","title":"Base","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.protocol","title":"<code>seapopym_optimization.observations.protocol</code>","text":"<p>Protocol for observations used in cost functions.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.protocol.ObservationProtocol","title":"<code>ObservationProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for observations used in cost function evaluation.</p> <p>Any observation object used in the optimization framework must implement this protocol. Observations represent empirical or reference data against which model predictions are compared.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.protocol.ObservationProtocol--attributes","title":"Attributes","text":"<p>name : str     Unique identifier or name of the observation. observation : object     The observation data. The type and structure depend on the cost function processor     (e.g., xarray.Dataset for time series or spatial data, numpy.ndarray for arrays).</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/observations/protocol.py</code> <pre><code>@runtime_checkable\nclass ObservationProtocol(Protocol):\n    \"\"\"Protocol for observations used in cost function evaluation.\n\n    Any observation object used in the optimization framework must implement this protocol.\n    Observations represent empirical or reference data against which model predictions are compared.\n\n    Attributes\n    ----------\n    name : str\n        Unique identifier or name of the observation.\n    observation : object\n        The observation data. The type and structure depend on the cost function processor\n        (e.g., xarray.Dataset for time series or spatial data, numpy.ndarray for arrays).\n\n    \"\"\"\n\n    name: str\n    observation: object\n</code></pre>"},{"location":"api/seapopym-optimization/#time-series","title":"Time Series","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.time_serie","title":"<code>seapopym_optimization.observations.time_serie</code>","text":"<p>This module contains the cost function used to optimize the parameters of the SeapoPym model.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.time_serie.TimeSeriesObservation","title":"<code>TimeSeriesObservation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Observation</code></p> <p>The structure used to store the observations as a time series.</p> <p>Meaning that the observation is a time series of biomass values at a given location and layer.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/observations/time_serie.py</code> <pre><code>@dataclass(kw_only=True)\nclass TimeSeriesObservation(Observation):\n    \"\"\"The structure used to store the observations as a time series.\n\n    Meaning that the observation is a time series of biomass values at a given location and layer.\n    \"\"\"\n\n    def __post_init__(self: TimeSeriesObservation) -&gt; None:\n        \"\"\"Check that the observation data is compliant with the format of the predicted biomass.\"\"\"\n        super().__post_init__()\n\n        for coord in [CoordinatesLabels.X, CoordinatesLabels.Y, CoordinatesLabels.Z]:\n            if self.observation.cf.coords[coord].data.size != 1:\n                msg = (\n                    f\"Multiple {coord} coordinates found in the observation Dataset. \"\n                    \"The observation must be a time series with a single X, Y and Z (i.e. Seapodym layer) coordinate.\"\n                )\n                raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.time_serie.TimeSeriesObservation.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that the observation data is compliant with the format of the predicted biomass.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/observations/time_serie.py</code> <pre><code>def __post_init__(self: TimeSeriesObservation) -&gt; None:\n    \"\"\"Check that the observation data is compliant with the format of the predicted biomass.\"\"\"\n    super().__post_init__()\n\n    for coord in [CoordinatesLabels.X, CoordinatesLabels.Y, CoordinatesLabels.Z]:\n        if self.observation.cf.coords[coord].data.size != 1:\n            msg = (\n                f\"Multiple {coord} coordinates found in the observation Dataset. \"\n                \"The observation must be a time series with a single X, Y and Z (i.e. Seapodym layer) coordinate.\"\n            )\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#spatial","title":"Spatial","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.spatial","title":"<code>seapopym_optimization.observations.spatial</code>","text":"<p>This module contains the cost function used to optimize the parameters of the SeapoPym model.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.spatial.SpatialObservation","title":"<code>SpatialObservation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Observation</code></p> <p>The structure used to store the observations as a spatial dataset.</p> <p>Meaning that the observation is a set of biomass values at given locations and times. The observation data must be an xarray.DataArray with a single dimension (e.g. \"index\" or \"obs_id\") and coordinates for time, latitude, and longitude.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/observations/spatial.py</code> <pre><code>@dataclass(kw_only=True)\nclass SpatialObservation(Observation):\n    \"\"\"The structure used to store the observations as a spatial dataset.\n\n    Meaning that the observation is a set of biomass values at given locations and times.\n    The observation data must be an xarray.DataArray with a single dimension (e.g. \"index\" or \"obs_id\")\n    and coordinates for time, latitude, and longitude.\n    \"\"\"\n\n    def __post_init__(self: SpatialObservation) -&gt; None:\n        \"\"\"Check that the observation data is compliant with the format of the predicted biomass.\"\"\"\n        super().__post_init__()\n\n        # Check for required coordinates\n        required_coords = [CoordinatesLabels.time, CoordinatesLabels.X, CoordinatesLabels.Y, CoordinatesLabels.Z]\n        for coord in required_coords:\n            if coord not in self.observation.coords:\n                msg = f\"Coordinate {coord} must be in the observation DataArray.\"\n                raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.observations.spatial.SpatialObservation.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that the observation data is compliant with the format of the predicted biomass.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/observations/spatial.py</code> <pre><code>def __post_init__(self: SpatialObservation) -&gt; None:\n    \"\"\"Check that the observation data is compliant with the format of the predicted biomass.\"\"\"\n    super().__post_init__()\n\n    # Check for required coordinates\n    required_coords = [CoordinatesLabels.time, CoordinatesLabels.X, CoordinatesLabels.Y, CoordinatesLabels.Z]\n    for coord in required_coords:\n        if coord not in self.observation.coords:\n            msg = f\"Coordinate {coord} must be in the observation DataArray.\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym-optimization/#constraints","title":"Constraints","text":""},{"location":"api/seapopym-optimization/#seapopym_optimization.constraint.energy_transfert_constraint","title":"<code>seapopym_optimization.constraint.energy_transfert_constraint</code>","text":"<p>All the constraints (as penalty functions) used by the DEAP library to contraint parameters initialization.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.constraint.energy_transfert_constraint.EnergyCoefficientConstraint","title":"<code>EnergyCoefficientConstraint</code>  <code>dataclass</code>","text":"<p>Constraint to ensure that the sum of all energy transfert coefficients is within a specified range.</p> <p>This constraint is used to apply a penalty if the sum of the coefficients is greater than <code>max_energy_coef_value</code> or less than <code>min_energy_coef_value</code>.</p>"},{"location":"api/seapopym-optimization/#seapopym_optimization.constraint.energy_transfert_constraint.EnergyCoefficientConstraint--attributes","title":"Attributes.","text":"<pre><code>parameters_name: Sequence[str]\n    The names of the parameters that are involved in the constraint, typically the energy transfert\n    coefficients.\nmin_energy_coef_value: float\n    The minimum allowed value for the sum of the energy transfert coefficients.\nmax_energy_coef_value: float\n    The maximum allowed value for the sum of the energy transfert coefficients.\n</code></pre> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/constraint/energy_transfert_constraint.py</code> <pre><code>@dataclass\nclass EnergyCoefficientConstraint:\n    \"\"\"Constraint to ensure that the sum of all energy transfert coefficients is within a specified range.\n\n    This constraint is used to apply a penalty if the sum of the coefficients is greater than `max_energy_coef_value`\n    or less than `min_energy_coef_value`.\n\n    Attributes.\n    ----------\n        parameters_name: Sequence[str]\n            The names of the parameters that are involved in the constraint, typically the energy transfert\n            coefficients.\n        min_energy_coef_value: float\n            The minimum allowed value for the sum of the energy transfert coefficients.\n        max_energy_coef_value: float\n            The maximum allowed value for the sum of the energy transfert coefficients.\n    \"\"\"\n\n    parameters_name: Sequence[str]\n    min_energy_coef_value: float\n    max_energy_coef_value: float\n\n    def _feasible(self, selected_index: list[int]) -&gt; Callable[[Sequence[float]], bool]:\n        \"\"\"Check if the energy transfer sum is within allowed bounds.\n\n        Validates that the sum of coefficients stays between the minimum and maximum defined values.\n        \"\"\"\n\n        def feasible(individual: Sequence[float], min_coef: float, max_coef: float) -&gt; bool:\n            total_coef = sum([individual[i] for i in selected_index])\n            return min_coef &lt;= total_coef &lt;= max_coef\n\n        return partial(feasible, min_coef=self.min_energy_coef_value, max_coef=self.max_energy_coef_value)\n\n    def generate(self, parameter_names: list[str]) -&gt; tools.DeltaPenalty:\n        \"\"\"Generate the DeltaPenalty object used by the DEAP library.\n\n        Apply the penalty on individuals that do not satisfy the constraint.\n        \"\"\"\n\n        def generate_index(ordered_names: list[str]) -&gt; list[int]:\n            \"\"\"List the index of the `parameters_name` in the `ordered_names` sequence.\n\n            This should be used by the feasible function to retrieve the position of the selected parameters.\n            \"\"\"\n            return [ordered_names.index(param) for param in self.parameters_name]\n\n        feasible = self._feasible(selected_index=generate_index(parameter_names))\n        return tools.DeltaPenalty(feasibility=feasible, delta=np.inf)\n</code></pre>"},{"location":"api/seapopym-optimization/#seapopym_optimization.constraint.energy_transfert_constraint.EnergyCoefficientConstraint.generate","title":"<code>generate(parameter_names)</code>","text":"<p>Generate the DeltaPenalty object used by the DEAP library.</p> <p>Apply the penalty on individuals that do not satisfy the constraint.</p> Source code in <code>packages/seapopym-optimization/src/seapopym_optimization/constraint/energy_transfert_constraint.py</code> <pre><code>def generate(self, parameter_names: list[str]) -&gt; tools.DeltaPenalty:\n    \"\"\"Generate the DeltaPenalty object used by the DEAP library.\n\n    Apply the penalty on individuals that do not satisfy the constraint.\n    \"\"\"\n\n    def generate_index(ordered_names: list[str]) -&gt; list[int]:\n        \"\"\"List the index of the `parameters_name` in the `ordered_names` sequence.\n\n        This should be used by the feasible function to retrieve the position of the selected parameters.\n        \"\"\"\n        return [ordered_names.index(param) for param in self.parameters_name]\n\n    feasible = self._feasible(selected_index=generate_index(parameter_names))\n    return tools.DeltaPenalty(feasibility=feasible, delta=np.inf)\n</code></pre>"},{"location":"api/seapopym/","title":"SeapoPym API Reference","text":""},{"location":"api/seapopym/#model","title":"Model","text":""},{"location":"api/seapopym/#notransportmodel","title":"NoTransportModel","text":""},{"location":"api/seapopym/#seapopym.model.no_transport_model","title":"<code>seapopym.model.no_transport_model</code>","text":"<p>The LMTL model without ADRE equations.</p> <p>LMTL stands for Lower Mid-Trophic Level. ADRE stands for Advection-Diffusion-Reaction Equation. This module implements a simplified version of the model where transport (advection and diffusion) is neglected, focusing on local biological processes.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel","title":"<code>NoTransportModel</code>  <code>dataclass</code>","text":"<p>Implement the LMTL model without the transport (Advection-Diffusion).</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel--attributes","title":"Attributes","text":"<p>state : SeapopymState     The model state containing all forcing data and parameters. kernel : Kernel     The computation kernel to be applied to the state.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>@dataclass\nclass NoTransportModel:\n    \"\"\"Implement the LMTL model without the transport (Advection-Diffusion).\n\n    Attributes\n    ----------\n    state : SeapopymState\n        The model state containing all forcing data and parameters.\n    kernel : Kernel\n        The computation kernel to be applied to the state.\n\n    \"\"\"\n\n    state: SeapopymState\n    kernel: Kernel\n\n    @classmethod\n    def from_configuration(cls: type[NoTransportModel], configuration: NoTransportConfiguration) -&gt; NoTransportModel:\n        \"\"\"Create a model from a configuration.\n\n        Parameters\n        ----------\n        configuration : NoTransportConfiguration\n            The configuration object containing state and parameters.\n\n        Returns\n        -------\n        NoTransportModel\n            An initialized model instance.\n\n        \"\"\"\n        if configuration.kernel.compute_initial_conditions:\n            kernel_class = NoTransportInitialConditionKernel\n        elif configuration.kernel.compute_preproduction:\n            kernel_class = NoTransportUnrecruitedKernel\n        else:\n            kernel_class = NoTransportKernel\n\n        state = configuration.state\n        chunk = configuration.forcing.chunk.as_dict()\n        parallel = configuration.forcing.parallel\n\n        return cls(state=state, kernel=kernel_class(chunk=chunk, parallel=parallel))\n\n    @property\n    def template(self: NoTransportModel) -&gt; SeapopymState:\n        \"\"\"The template getter.\n\n        Returns\n        -------\n        SeapopymState\n            The template representing the structure of the model output.\n\n        \"\"\"\n        return self.kernel.template(self.state)\n\n    @property\n    def expected_memory_usage(self: NoTransportModel) -&gt; str:\n        \"\"\"Return the expected memory usage of the model state in MB.\n\n        Returns\n        -------\n        str\n            A string describing the memory usage in MB.\n\n        \"\"\"\n        return f\"The expected memory usage is {self.template.nbytes / 1e6:.2f} MB.\"\n\n    def run(self: NoTransportModel) -&gt; None:\n        \"\"\"Run the model. Wrapper of the pre-production, production and post-production processes.\n\n        The model state is updated in place.\n        \"\"\"\n        self.state = self.kernel.run(self.state)\n\n    def export_initial_conditions(self: NoTransportModel) -&gt; xr.Dataset:\n        \"\"\"Export the initial conditions.\n\n        Returns\n        -------\n        xr.Dataset\n            A dataset containing the initial conditions (biomass and preproduction).\n\n        Raises\n        ------\n        ValueError\n            If the model was not run with compute_initial_conditions or compute_preproduction set to True.\n\n        \"\"\"\n        if (\n            not self.state[ConfigurationLabels.compute_initial_conditions]\n            and not self.state[ConfigurationLabels.compute_preproduction]\n        ):\n            msg = (\n                \"To export initial conditions, the model must be run with the compute_initial_conditions or \"\n                \"compute_preproduction flag set to True.\"\n            )\n            raise ValueError(msg)\n        return self.state[[ForcingLabels.biomass, ForcingLabels.preproduction]].isel(T=-1)\n\n    def __enter__(self: NoTransportModel) -&gt; Self:\n        \"\"\"Enter context manager.\n\n        Returns\n        -------\n        Self\n            The model instance.\n\n        \"\"\"\n        return self\n\n    def __exit__(\n        self: NoTransportModel,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit context manager and cleanup memory.\n\n        Parameters\n        ----------\n        exc_type : type[BaseException] | None\n            The exception type if an exception was raised.\n        exc_value : BaseException | None\n            The exception value if an exception was raised.\n        traceback : TracebackType | None\n            The traceback if an exception was raised.\n\n        \"\"\"\n        # Clean up large objects\n        if hasattr(self, \"state\"):\n            del self.state\n        if hasattr(self, \"kernel\"):\n            del self.kernel\n\n        # Force garbage collection for genetic algorithms usage\n        gc.collect()\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.template","title":"<code>template</code>  <code>property</code>","text":"<p>The template getter.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.template--returns","title":"Returns","text":"<p>SeapopymState     The template representing the structure of the model output.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.expected_memory_usage","title":"<code>expected_memory_usage</code>  <code>property</code>","text":"<p>Return the expected memory usage of the model state in MB.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.expected_memory_usage--returns","title":"Returns","text":"<p>str     A string describing the memory usage in MB.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.from_configuration","title":"<code>from_configuration(configuration)</code>  <code>classmethod</code>","text":"<p>Create a model from a configuration.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.from_configuration--parameters","title":"Parameters","text":"<p>configuration : NoTransportConfiguration     The configuration object containing state and parameters.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.from_configuration--returns","title":"Returns","text":"<p>NoTransportModel     An initialized model instance.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>@classmethod\ndef from_configuration(cls: type[NoTransportModel], configuration: NoTransportConfiguration) -&gt; NoTransportModel:\n    \"\"\"Create a model from a configuration.\n\n    Parameters\n    ----------\n    configuration : NoTransportConfiguration\n        The configuration object containing state and parameters.\n\n    Returns\n    -------\n    NoTransportModel\n        An initialized model instance.\n\n    \"\"\"\n    if configuration.kernel.compute_initial_conditions:\n        kernel_class = NoTransportInitialConditionKernel\n    elif configuration.kernel.compute_preproduction:\n        kernel_class = NoTransportUnrecruitedKernel\n    else:\n        kernel_class = NoTransportKernel\n\n    state = configuration.state\n    chunk = configuration.forcing.chunk.as_dict()\n    parallel = configuration.forcing.parallel\n\n    return cls(state=state, kernel=kernel_class(chunk=chunk, parallel=parallel))\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.run","title":"<code>run()</code>","text":"<p>Run the model. Wrapper of the pre-production, production and post-production processes.</p> <p>The model state is updated in place.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>def run(self: NoTransportModel) -&gt; None:\n    \"\"\"Run the model. Wrapper of the pre-production, production and post-production processes.\n\n    The model state is updated in place.\n    \"\"\"\n    self.state = self.kernel.run(self.state)\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.export_initial_conditions","title":"<code>export_initial_conditions()</code>","text":"<p>Export the initial conditions.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.export_initial_conditions--returns","title":"Returns","text":"<p>xr.Dataset     A dataset containing the initial conditions (biomass and preproduction).</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.export_initial_conditions--raises","title":"Raises","text":"<p>ValueError     If the model was not run with compute_initial_conditions or compute_preproduction set to True.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>def export_initial_conditions(self: NoTransportModel) -&gt; xr.Dataset:\n    \"\"\"Export the initial conditions.\n\n    Returns\n    -------\n    xr.Dataset\n        A dataset containing the initial conditions (biomass and preproduction).\n\n    Raises\n    ------\n    ValueError\n        If the model was not run with compute_initial_conditions or compute_preproduction set to True.\n\n    \"\"\"\n    if (\n        not self.state[ConfigurationLabels.compute_initial_conditions]\n        and not self.state[ConfigurationLabels.compute_preproduction]\n    ):\n        msg = (\n            \"To export initial conditions, the model must be run with the compute_initial_conditions or \"\n            \"compute_preproduction flag set to True.\"\n        )\n        raise ValueError(msg)\n    return self.state[[ForcingLabels.biomass, ForcingLabels.preproduction]].isel(T=-1)\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter context manager.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.__enter__--returns","title":"Returns","text":"<p>Self     The model instance.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>def __enter__(self: NoTransportModel) -&gt; Self:\n    \"\"\"Enter context manager.\n\n    Returns\n    -------\n    Self\n        The model instance.\n\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Exit context manager and cleanup memory.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportModel.__exit__--parameters","title":"Parameters","text":"<p>exc_type : type[BaseException] | None     The exception type if an exception was raised. exc_value : BaseException | None     The exception value if an exception was raised. traceback : TracebackType | None     The traceback if an exception was raised.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>def __exit__(\n    self: NoTransportModel,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit context manager and cleanup memory.\n\n    Parameters\n    ----------\n    exc_type : type[BaseException] | None\n        The exception type if an exception was raised.\n    exc_value : BaseException | None\n        The exception value if an exception was raised.\n    traceback : TracebackType | None\n        The traceback if an exception was raised.\n\n    \"\"\"\n    # Clean up large objects\n    if hasattr(self, \"state\"):\n        del self.state\n    if hasattr(self, \"kernel\"):\n        del self.kernel\n\n    # Force garbage collection for genetic algorithms usage\n    gc.collect()\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportLightModel","title":"<code>NoTransportLightModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>NoTransportModel</code></p> <p>Implement the LMTL model without the transport (Advection-Diffusion) and with light kernel.</p> <p>The Light model removes intermediate variables from the state during computation to reduce memory usage.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>@dataclass\nclass NoTransportLightModel(NoTransportModel):\n    \"\"\"Implement the LMTL model without the transport (Advection-Diffusion) and with light kernel.\n\n    The Light model removes intermediate variables from the state during computation\n    to reduce memory usage.\n    \"\"\"\n\n    @classmethod\n    def from_configuration(\n        cls: type[NoTransportLightModel], configuration: NoTransportConfiguration\n    ) -&gt; NoTransportLightModel:\n        \"\"\"Create a model from a configuration.\n\n        Parameters\n        ----------\n        configuration : NoTransportConfiguration\n            The configuration object.\n\n        Returns\n        -------\n        NoTransportLightModel\n            An initialized light model instance.\n\n        \"\"\"\n        if configuration.kernel.compute_initial_conditions:\n            kernel_class = NoTransportInitialConditionKernelLight\n        elif configuration.kernel.compute_preproduction:\n            kernel_class = NoTransportUnrecruitedKernelLight\n        else:\n            kernel_class = NoTransportKernelLight\n\n        state = configuration.state\n        chunk = configuration.forcing.chunk.as_dict()\n        parallel = configuration.forcing.parallel\n\n        return cls(state=state, kernel=kernel_class(chunk=chunk, parallel=parallel))\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportLightModel.from_configuration","title":"<code>from_configuration(configuration)</code>  <code>classmethod</code>","text":"<p>Create a model from a configuration.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportLightModel.from_configuration--parameters","title":"Parameters","text":"<p>configuration : NoTransportConfiguration     The configuration object.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportLightModel.from_configuration--returns","title":"Returns","text":"<p>NoTransportLightModel     An initialized light model instance.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>@classmethod\ndef from_configuration(\n    cls: type[NoTransportLightModel], configuration: NoTransportConfiguration\n) -&gt; NoTransportLightModel:\n    \"\"\"Create a model from a configuration.\n\n    Parameters\n    ----------\n    configuration : NoTransportConfiguration\n        The configuration object.\n\n    Returns\n    -------\n    NoTransportLightModel\n        An initialized light model instance.\n\n    \"\"\"\n    if configuration.kernel.compute_initial_conditions:\n        kernel_class = NoTransportInitialConditionKernelLight\n    elif configuration.kernel.compute_preproduction:\n        kernel_class = NoTransportUnrecruitedKernelLight\n    else:\n        kernel_class = NoTransportKernelLight\n\n    state = configuration.state\n    chunk = configuration.forcing.chunk.as_dict()\n    parallel = configuration.forcing.parallel\n\n    return cls(state=state, kernel=kernel_class(chunk=chunk, parallel=parallel))\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportSpaceOptimizedLightModel","title":"<code>NoTransportSpaceOptimizedLightModel</code>  <code>dataclass</code>","text":"<p>               Bases: <code>NoTransportModel</code></p> <p>Implement the LMTL model without the transport (Advection-Diffusion) and with light kernel.</p> <p>This version uses a space-optimized production kernel to further reduce memory footprint.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>@dataclass\nclass NoTransportSpaceOptimizedLightModel(NoTransportModel):\n    \"\"\"Implement the LMTL model without the transport (Advection-Diffusion) and with light kernel.\n\n    This version uses a space-optimized production kernel to further reduce memory footprint.\n    \"\"\"\n\n    @classmethod\n    def from_configuration(\n        cls: type[NoTransportSpaceOptimizedLightModel], configuration: NoTransportConfiguration\n    ) -&gt; NoTransportSpaceOptimizedLightModel:\n        \"\"\"Create a model from a configuration.\n\n        Parameters\n        ----------\n        configuration : NoTransportConfiguration\n            The configuration object.\n\n        Returns\n        -------\n        NoTransportSpaceOptimizedLightModel\n            An initialized space-optimized light model instance.\n\n        \"\"\"\n        state = configuration.state\n        chunk = configuration.forcing.chunk.as_dict()\n        parallel = configuration.forcing.parallel\n\n        return cls(state=state, kernel=NoTransportSpaceOptimizedKernelLight(chunk=chunk, parallel=parallel))\n</code></pre>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportSpaceOptimizedLightModel.from_configuration","title":"<code>from_configuration(configuration)</code>  <code>classmethod</code>","text":"<p>Create a model from a configuration.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportSpaceOptimizedLightModel.from_configuration--parameters","title":"Parameters","text":"<p>configuration : NoTransportConfiguration     The configuration object.</p>"},{"location":"api/seapopym/#seapopym.model.no_transport_model.NoTransportSpaceOptimizedLightModel.from_configuration--returns","title":"Returns","text":"<p>NoTransportSpaceOptimizedLightModel     An initialized space-optimized light model instance.</p> Source code in <code>packages/seapopym/src/seapopym/model/no_transport_model.py</code> <pre><code>@classmethod\ndef from_configuration(\n    cls: type[NoTransportSpaceOptimizedLightModel], configuration: NoTransportConfiguration\n) -&gt; NoTransportSpaceOptimizedLightModel:\n    \"\"\"Create a model from a configuration.\n\n    Parameters\n    ----------\n    configuration : NoTransportConfiguration\n        The configuration object.\n\n    Returns\n    -------\n    NoTransportSpaceOptimizedLightModel\n        An initialized space-optimized light model instance.\n\n    \"\"\"\n    state = configuration.state\n    chunk = configuration.forcing.chunk.as_dict()\n    parallel = configuration.forcing.parallel\n\n    return cls(state=state, kernel=NoTransportSpaceOptimizedKernelLight(chunk=chunk, parallel=parallel))\n</code></pre>"},{"location":"api/seapopym/#configuration","title":"Configuration","text":""},{"location":"api/seapopym/#notransport-configuration","title":"NoTransport Configuration","text":""},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration","title":"<code>seapopym.configuration.no_transport.configuration</code>","text":"<p>This module contains the configuration of the model as a xarray.Dataset.</p> <p>It allows to store the model parameters and the forcings (lazily).</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration","title":"<code>NoTransportConfiguration</code>","text":"<p>Configuration for the NoTransportModel.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration--attributes","title":"Attributes","text":"<p>forcing : ForcingParameter     The forcing parameters for the configuration. functional_group : FunctionalGroupParameter     The functional group parameters for the configuration. kernel : KernelParameter     The kernel parameters for the configuration.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/configuration.py</code> <pre><code>@frozen(kw_only=True)\nclass NoTransportConfiguration:\n    \"\"\"Configuration for the NoTransportModel.\n\n    Attributes\n    ----------\n    forcing : ForcingParameter\n        The forcing parameters for the configuration.\n    functional_group : FunctionalGroupParameter\n        The functional group parameters for the configuration.\n    kernel : KernelParameter\n        The kernel parameters for the configuration.\n\n    \"\"\"\n\n    forcing: ForcingParameter = field(metadata={\"description\": \"The forcing parameters for the configuration.\"})\n    functional_group: FunctionalGroupParameter = field(\n        metadata={\"description\": \"The functional group parameters for the configuration.\"}\n    )\n\n    kernel: KernelParameter = field(\n        factory=KernelParameter, metadata={\"description\": \"The kernel parameters for the configuration.\"}\n    )\n\n    @property\n    def state(self: NoTransportConfiguration) -&gt; SeapopymState:\n        \"\"\"The xarray.Dataset that stores the state of the model. Data is sent to worker if chunked.\n\n        Returns\n        -------\n        SeapopymState\n            The merged dataset containing forcing, functional group, and kernel parameters.\n\n        \"\"\"\n        data = self.forcing.to_dataset()\n        timestep = pint.Quantity(data.indexes[\"T\"].to_series().diff().dt.days.iloc[1], \"day\")  # Directly as Quantity\n        data = xr.merge(\n            [\n                data,\n                self.functional_group.to_dataset(timestep=timestep),\n                {ConfigurationLabels.timestep: timestep},\n                self.kernel.to_dataset(),\n            ],\n            combine_attrs=\"no_conflicts\",\n            join=\"outer\",\n        ).pint.dequantify()\n        data = CoordinatesLabels.order_data(data)\n        if self.forcing.parallel:\n            data = data.chunk(self.forcing.chunk.as_dict())\n        return data.persist()\n\n    @classmethod\n    def parse(cls: NoTransportConfiguration, configuration_file: str | Path | IO) -&gt; NoTransportConfiguration:\n        \"\"\"Parse the configuration file and create a NoTransportConfiguration object.\n\n        Parameters\n        ----------\n        configuration_file : str | Path | IO\n            Path to the configuration file or file-like object.\n\n        Returns\n        -------\n        NoTransportConfiguration\n            The parsed configuration object.\n\n        Raises\n        ------\n        NotImplementedError\n            This method is not implemented yet.\n\n        \"\"\"\n        msg = \"This method is not implemented yet.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration.state","title":"<code>state</code>  <code>property</code>","text":"<p>The xarray.Dataset that stores the state of the model. Data is sent to worker if chunked.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration.state--returns","title":"Returns","text":"<p>SeapopymState     The merged dataset containing forcing, functional group, and kernel parameters.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration.parse","title":"<code>parse(configuration_file)</code>  <code>classmethod</code>","text":"<p>Parse the configuration file and create a NoTransportConfiguration object.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration.parse--parameters","title":"Parameters","text":"<p>configuration_file : str | Path | IO     Path to the configuration file or file-like object.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration.parse--returns","title":"Returns","text":"<p>NoTransportConfiguration     The parsed configuration object.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.configuration.NoTransportConfiguration.parse--raises","title":"Raises","text":"<p>NotImplementedError     This method is not implemented yet.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/configuration.py</code> <pre><code>@classmethod\ndef parse(cls: NoTransportConfiguration, configuration_file: str | Path | IO) -&gt; NoTransportConfiguration:\n    \"\"\"Parse the configuration file and create a NoTransportConfiguration object.\n\n    Parameters\n    ----------\n    configuration_file : str | Path | IO\n        Path to the configuration file or file-like object.\n\n    Returns\n    -------\n    NoTransportConfiguration\n        The parsed configuration object.\n\n    Raises\n    ------\n    NotImplementedError\n        This method is not implemented yet.\n\n    \"\"\"\n    msg = \"This method is not implemented yet.\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"api/seapopym/#notransport-parameters","title":"NoTransport Parameters","text":""},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter","title":"<code>seapopym.configuration.no_transport.forcing_parameter</code>","text":"<p>Define the ForcingUnit data class used to store access paths to a forcing field.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ChunkParameter","title":"<code>ChunkParameter</code>","text":"<p>The chunk size of the different dimensions.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>@frozen\nclass ChunkParameter:\n    \"\"\"The chunk size of the different dimensions.\"\"\"\n\n    functional_group: Literal[\"auto\"] | int | None = field(\n        default=1,\n        validator=validators.optional(validators.instance_of((str, int))),\n        metadata={\"description\": \"The chunk size of the functional group dimension.\"},\n    )\n    Y: Literal[\"auto\"] | int | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of((str, int))),\n        metadata={\"description\": \"The chunk size of the Y (latitude) dimension.\"},\n    )\n    X: Literal[\"auto\"] | int | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of((str, int))),\n        metadata={\"description\": \"The chunk size of the X (longitude) dimension.\"},\n    )\n    T: Literal[-1] = field(\n        init=False,\n        default=-1,\n        metadata={\n            \"description\": (\n                \"The chunk size of the T (time) dimension. \"\n                \"Present only to remind us that time is not divisible due to time dependencies.\"\n            )\n        },\n    )\n\n    def as_dict(self: ChunkParameter) -&gt; dict:\n        \"\"\"Format to a dictionary as expected by xarray with standardized coordinates.\"\"\"\n        chunks = {}\n        if self.functional_group is not None:\n            chunks[\"functional_group\"] = self.functional_group\n        if self.Y is not None:\n            chunks[\"Y\"] = self.Y\n        if self.X is not None:\n            chunks[\"X\"] = self.X\n        chunks[\"T\"] = self.T\n        return chunks\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ChunkParameter.as_dict","title":"<code>as_dict()</code>","text":"<p>Format to a dictionary as expected by xarray with standardized coordinates.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>def as_dict(self: ChunkParameter) -&gt; dict:\n    \"\"\"Format to a dictionary as expected by xarray with standardized coordinates.\"\"\"\n    chunks = {}\n    if self.functional_group is not None:\n        chunks[\"functional_group\"] = self.functional_group\n    if self.Y is not None:\n        chunks[\"Y\"] = self.Y\n    if self.X is not None:\n        chunks[\"X\"] = self.X\n    chunks[\"T\"] = self.T\n    return chunks\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit","title":"<code>ForcingUnit</code>","text":"<p>This data class is used to store a forcing field.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit--parameters","title":"Parameters","text":"<p>forcing: xr.DataArray     Forcing field.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit--notes","title":"Notes","text":"<ul> <li>This class is used to store a forcing field.</li> <li>Be sure to follow the CF conventions for the forcing file. To do so you can use the <code>cf_xarray</code> package.</li> </ul> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>@frozen(kw_only=True)\nclass ForcingUnit:\n    \"\"\"This data class is used to store a forcing field.\n\n    Parameters\n    ----------\n    forcing: xr.DataArray\n        Forcing field.\n\n\n    Notes\n    -----\n    - This class is used to store a forcing field.\n    - Be sure to follow the CF conventions for the forcing file. To do so you can use the `cf_xarray` package.\n\n    \"\"\"\n\n    forcing: xr.DataArray = field(\n        converter=xr.DataArray,\n        metadata={\"description\": \"Forcing field.\"},\n    )\n\n    def __attrs_post_init__(self: ForcingUnit) -&gt; None:\n        \"\"\"Apply coordinate standardization after initialization.\"\"\"\n        standardized_forcing = self._standardize_coordinates(self.forcing)\n        # Use object.__setattr__ because @frozen prevents normal assignment\n        object.__setattr__(self, \"forcing\", standardized_forcing)\n\n    @classmethod\n    def from_dataset(\n        cls: ForcingUnit,\n        forcing: xr.Dataset,\n        name: str,\n    ) -&gt; ForcingUnit:\n        \"\"\"Create a ForcingUnit from a path and a name with standardized coordinate names.\"\"\"\n        if name not in forcing:\n            message = f\"DataArray {name} is not in the Dataset.\\nAccepted values are : {', '.join(list(forcing))}\"\n            raise ValueError(message)\n\n        data_array = forcing[name]\n        # La standardisation se fait automatiquement dans __attrs_post_init__\n        return cls(forcing=data_array)\n\n    @staticmethod\n    def _standardize_coordinates(data_array: xr.DataArray) -&gt; xr.DataArray:\n        \"\"\"Rename coordinates to T/Y/X/Z using cf_xarray, keep attributes.\"\"\"\n        coord_mapping = {}\n\n        try:\n            if \"T\" in data_array.cf:\n                original_time = data_array.cf[\"T\"].name\n                if original_time != \"T\":\n                    coord_mapping[original_time] = \"T\"\n\n            if \"Y\" in data_array.cf:\n                original_lat = data_array.cf[\"Y\"].name\n                if original_lat != \"Y\":\n                    coord_mapping[original_lat] = \"Y\"\n\n            if \"X\" in data_array.cf:\n                original_lon = data_array.cf[\"X\"].name\n                if original_lon != \"X\":\n                    coord_mapping[original_lon] = \"X\"\n\n            if \"Z\" in data_array.cf:\n                original_z = data_array.cf[\"Z\"].name\n                if original_z != \"Z\":\n                    coord_mapping[original_z] = \"Z\"\n\n        except Exception as e:\n            logger.warning(f\"Could not standardize coordinates using cf_xarray: {e}. Keeping original names.\")\n            return data_array\n\n        if coord_mapping:\n            logger.info(f\"Standardizing coordinates: {coord_mapping}\")\n            return data_array.rename(coord_mapping)\n\n        return data_array\n\n    @classmethod\n    def from_path(\n        cls: ForcingUnit,\n        forcing: Path | str,\n        name: str,\n        engine: Literal[\"zarr\", \"netcdf\"] = \"zarr\",\n        *args: ParamSpecArgs,\n        **kwargs: ParamSpecKwargs,\n    ) -&gt; ForcingUnit:\n        \"\"\"Create a ForcingUnit from a path and a name.\"\"\"\n        path_validation(forcing)\n        data = xr.open_dataset(forcing, *args, engine=engine, **kwargs)\n        return cls.from_dataset(data, name)\n\n    def convert(self: ForcingUnit, units: str | Unit) -&gt; ForcingUnit:\n        \"\"\"Create a new ForcingUnit with the same forcing field but with a different unit.\n\n        Parameters.\n        ----------\n        units: str | Unit\n            The unit to convert the forcing field to. If a string is provided, it will be converted to a Pint Unit.\n            If a Pint Unit is provided, it will be used as is.\n        \"\"\"\n        try:\n            if isinstance(units, str):\n                units = pint.Unit(units)\n        except pint.errors.UndefinedUnitError as e:\n            msg = f\"Unit {units} is not defined in Pint.\"\n            raise ValueError(msg) from e\n\n        if self.forcing.pint.units is None:\n            try:\n                forcing = self.forcing.pint.quantify()\n            except pint.errors.DimensionalityError as e:\n                message = f\"Cannot quantify {self.forcing.name} because it has no units.\"\n                raise ValueError(message) from e\n\n        if forcing.pint.units != units:\n            message = f\"{forcing.name} unit is {forcing.pint.units}, it will be converted to {units}.\"\n            logger.warning(message)\n        try:\n            forcing = forcing.pint.to(units)\n        except Exception as e:\n            message = f\"Failed to convert forcing to {units}. forcing is in {forcing.pint.units}.\"\n            logger.exception(message)\n            raise type(e)(message) from e\n\n        return type(self)(forcing=forcing.pint.dequantify())\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Apply coordinate standardization after initialization.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>def __attrs_post_init__(self: ForcingUnit) -&gt; None:\n    \"\"\"Apply coordinate standardization after initialization.\"\"\"\n    standardized_forcing = self._standardize_coordinates(self.forcing)\n    # Use object.__setattr__ because @frozen prevents normal assignment\n    object.__setattr__(self, \"forcing\", standardized_forcing)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit.from_dataset","title":"<code>from_dataset(forcing, name)</code>  <code>classmethod</code>","text":"<p>Create a ForcingUnit from a path and a name with standardized coordinate names.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>@classmethod\ndef from_dataset(\n    cls: ForcingUnit,\n    forcing: xr.Dataset,\n    name: str,\n) -&gt; ForcingUnit:\n    \"\"\"Create a ForcingUnit from a path and a name with standardized coordinate names.\"\"\"\n    if name not in forcing:\n        message = f\"DataArray {name} is not in the Dataset.\\nAccepted values are : {', '.join(list(forcing))}\"\n        raise ValueError(message)\n\n    data_array = forcing[name]\n    # La standardisation se fait automatiquement dans __attrs_post_init__\n    return cls(forcing=data_array)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit.from_path","title":"<code>from_path(forcing, name, engine='zarr', *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a ForcingUnit from a path and a name.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>@classmethod\ndef from_path(\n    cls: ForcingUnit,\n    forcing: Path | str,\n    name: str,\n    engine: Literal[\"zarr\", \"netcdf\"] = \"zarr\",\n    *args: ParamSpecArgs,\n    **kwargs: ParamSpecKwargs,\n) -&gt; ForcingUnit:\n    \"\"\"Create a ForcingUnit from a path and a name.\"\"\"\n    path_validation(forcing)\n    data = xr.open_dataset(forcing, *args, engine=engine, **kwargs)\n    return cls.from_dataset(data, name)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit.convert","title":"<code>convert(units)</code>","text":"<p>Create a new ForcingUnit with the same forcing field but with a different unit.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingUnit.convert--parameters","title":"Parameters.","text":"<p>units: str | Unit     The unit to convert the forcing field to. If a string is provided, it will be converted to a Pint Unit.     If a Pint Unit is provided, it will be used as is.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>def convert(self: ForcingUnit, units: str | Unit) -&gt; ForcingUnit:\n    \"\"\"Create a new ForcingUnit with the same forcing field but with a different unit.\n\n    Parameters.\n    ----------\n    units: str | Unit\n        The unit to convert the forcing field to. If a string is provided, it will be converted to a Pint Unit.\n        If a Pint Unit is provided, it will be used as is.\n    \"\"\"\n    try:\n        if isinstance(units, str):\n            units = pint.Unit(units)\n    except pint.errors.UndefinedUnitError as e:\n        msg = f\"Unit {units} is not defined in Pint.\"\n        raise ValueError(msg) from e\n\n    if self.forcing.pint.units is None:\n        try:\n            forcing = self.forcing.pint.quantify()\n        except pint.errors.DimensionalityError as e:\n            message = f\"Cannot quantify {self.forcing.name} because it has no units.\"\n            raise ValueError(message) from e\n\n    if forcing.pint.units != units:\n        message = f\"{forcing.name} unit is {forcing.pint.units}, it will be converted to {units}.\"\n        logger.warning(message)\n    try:\n        forcing = forcing.pint.to(units)\n    except Exception as e:\n        message = f\"Failed to convert forcing to {units}. forcing is in {forcing.pint.units}.\"\n        logger.exception(message)\n        raise type(e)(message) from e\n\n    return type(self)(forcing=forcing.pint.dequantify())\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingParameter","title":"<code>ForcingParameter</code>","text":"<p>This data class is used to store access paths to forcing fields.</p> <p>You can inherit it to add further forcings, but in this case you'll need to add new behaviors to the functions and classes that follow.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>@frozen(kw_only=True)\nclass ForcingParameter:\n    \"\"\"This data class is used to store access paths to forcing fields.\n\n    You can inherit it to add further forcings, but in this case you'll need to add new behaviors to the functions and\n    classes that follow.\n    \"\"\"\n\n    temperature: ForcingUnit = field(\n        alias=ForcingLabels.temperature,\n        converter=partial(\n            verify_forcing_init, unit=StandardUnitsLabels.temperature.units, parameter_name=ForcingLabels.temperature\n        ),\n        validator=validators.instance_of(ForcingUnit),\n        metadata={\"description\": \"Path to the temperature field.\"},\n    )\n    primary_production: ForcingUnit = field(\n        alias=ForcingLabels.primary_production,\n        converter=partial(\n            verify_forcing_init,\n            unit=StandardUnitsLabels.production.units,\n            parameter_name=ForcingLabels.primary_production,\n        ),\n        validator=validators.instance_of(ForcingUnit),\n        metadata={\"description\": \"Path to the primary production field.\"},\n    )\n\n    initial_condition_production: ForcingUnit | None = field(\n        alias=ConfigurationLabels.initial_condition_production,\n        default=None,\n        converter=converters.optional(\n            partial(\n                verify_forcing_init,\n                unit=StandardUnitsLabels.production.units,\n                parameter_name=ConfigurationLabels.initial_condition_production,\n            )\n        ),\n        validator=validators.optional(validators.instance_of(ForcingUnit)),\n        metadata={\"description\": \"Path to the initial condition production field.\", \"dims\": \"Fgroup, &lt;Y, X,&gt; Cohort\"},\n    )\n\n    initial_condition_biomass: ForcingUnit | None = field(\n        alias=ConfigurationLabels.initial_condition_biomass,\n        default=None,\n        converter=converters.optional(\n            partial(\n                verify_forcing_init,\n                unit=StandardUnitsLabels.biomass.units,\n                parameter_name=ConfigurationLabels.initial_condition_biomass,\n            )\n        ),\n        validator=validators.optional(validators.instance_of(ForcingUnit)),\n        metadata={\"description\": \"Path to the initial condition biomass field.\", \"dims\": \"Fgroup, &lt;Y, X&gt;\"},\n    )\n\n    parallel: bool = field(\n        default=False,\n        validator=validators.instance_of(bool),\n        metadata={\"description\": \"Enable parallel computation with Dask. Requires active Dask client.\"},\n    )\n\n    chunk: ChunkParameter = field(\n        factory=ChunkParameter,\n        validator=validators.instance_of(ChunkParameter),\n        metadata={\"description\": \"The chunk size of the different dimensions for parallel computation.\"},\n    )\n\n    def __attrs_post_init__(self: ForcingParameter) -&gt; None:\n        \"\"\"Post initialization with flexible coherence validation.\"\"\"\n        # 0. Check parallel computation setup\n        if self.parallel:\n            self._validate_dask_client()\n        self._validate_forcing_consistency()\n\n        # 1. Validation de coh\u00e9rence flexible (remplace validation timestep basique)\n        validate_coordinate_coherence(self.all_forcings)\n\n        # 2. Check nans consistency\n        self._validate_nan_consistency()\n\n    def _validate_nan_consistency(self: ForcingParameter) -&gt; None:\n        \"\"\"Validate NaN consistency across time for all forcings.\"\"\"\n        for name, forcing in self.all_forcings.items():\n            if \"T\" in forcing.forcing.coords:\n                valid_counts: xr.DataArray = forcing.forcing.notnull().sum(dim=\"T\")\n                total_timesteps = forcing.forcing.sizes[\"T\"]\n                inconsistent_cells = (valid_counts &gt; 0) &amp; (valid_counts &lt; total_timesteps)\n                if inconsistent_cells.any():\n                    message = (\n                        f\"Warning: {name} has cells with inconsistent NaN patterns across time. These cells have valid \"\n                        \"values for some timesteps but NaN for others. This may cause issues with global mask \"\n                        \"generation.\"\n                    )\n                    logger.warning(message)\n\n    @property\n    def all_forcings(self: ForcingParameter) -&gt; dict[str, ForcingUnit]:\n        \"\"\"Return all the not null ForcingUnit as a dictionary.\"\"\"\n        return asdict(self, recurse=False, filter=lambda _, value: isinstance(value, ForcingUnit))\n\n    def to_dataset(self) -&gt; xr.Dataset:\n        \"\"\"An xarray.Dataset containing all the forcing fields used to construct the SeapoPymState.\"\"\"\n        return xr.Dataset({k: v.forcing for k, v in self.all_forcings.items() if v.forcing is not None})\n\n    def _validate_dask_client(self: ForcingParameter) -&gt; None:\n        \"\"\"Ensure Dask client is available for parallel computation.\"\"\"\n        try:\n            from dask.distributed import get_client\n\n            get_client()\n            logger.info(\"Dask client found, parallel computation enabled.\")\n        except (ImportError, ValueError) as e:\n            msg = (\n                \"parallel=True requires an active Dask client. \"\n                \"Start a client with: from dask.distributed import Client; client = Client()\"\n            )\n            raise RuntimeError(msg) from e\n\n    def _validate_forcing_consistency(self: ForcingParameter) -&gt; None:\n        \"\"\"Validate consistency between parallel setting and forcing memory status.\"\"\"\n        dask_arrays = [hasattr(forcing.forcing.data, \"chunks\") for forcing in self.all_forcings.values()]\n\n        if self.parallel and not all(dask_arrays):\n            msg = (\n                \"parallel=True but forcings are loaded in memory (numpy arrays). \"\n                \"For distributed computation, use chunked loading. Example:\\n\"\n                \"  forcing = xr.open_dataset('file.nc', chunks={'T': -1, 'Y': 180})\\n\"\n                \"Or scatter existing arrays:\\n\"\n                \"  from dask.distributed import get_client\\n\"\n                \"  client = get_client()\\n\"\n                \"  scattered_forcing = client.scatter(forcing, broadcast=True)\"\n            )\n            raise ValueError(msg)\n\n        if not self.parallel and any(dask_arrays):\n            msg = (\n                \"parallel=False but forcings contain Dask arrays (lazy loading). \"\n                \"For non-parallel computation, load forcings into memory:\\n\"\n                \"  forcing = forcing.load()  # or .compute()\\n\"\n                \"Or enable parallel computation:\\n\"\n                \"  parallel=True\"\n            )\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingParameter.all_forcings","title":"<code>all_forcings</code>  <code>property</code>","text":"<p>Return all the not null ForcingUnit as a dictionary.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingParameter.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Post initialization with flexible coherence validation.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>def __attrs_post_init__(self: ForcingParameter) -&gt; None:\n    \"\"\"Post initialization with flexible coherence validation.\"\"\"\n    # 0. Check parallel computation setup\n    if self.parallel:\n        self._validate_dask_client()\n    self._validate_forcing_consistency()\n\n    # 1. Validation de coh\u00e9rence flexible (remplace validation timestep basique)\n    validate_coordinate_coherence(self.all_forcings)\n\n    # 2. Check nans consistency\n    self._validate_nan_consistency()\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.ForcingParameter.to_dataset","title":"<code>to_dataset()</code>","text":"<p>An xarray.Dataset containing all the forcing fields used to construct the SeapoPymState.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>def to_dataset(self) -&gt; xr.Dataset:\n    \"\"\"An xarray.Dataset containing all the forcing fields used to construct the SeapoPymState.\"\"\"\n    return xr.Dataset({k: v.forcing for k, v in self.all_forcings.items() if v.forcing is not None})\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.forcing_parameter.path_validation","title":"<code>path_validation(path)</code>","text":"<p>Check if the path exists.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/forcing_parameter.py</code> <pre><code>def path_validation(path: str | Path) -&gt; str | Path:\n    \"\"\"Check if the path exists.\"\"\"\n    with fsspec.open(str(path)) as file:\n        if \"file\" not in file.fs.protocol:\n            message = f\"Remote file : {file.fs.protocol}\"\n            logger.info(message)\n            return str(path)\n        if \"file\" in file.fs.protocol and Path(path).exists():\n            message = f\"Local file : ({file.fs.protocol})\"\n            logger.debug(message)\n            return Path(path)\n    msg = f\"Cannot reach '{path}'.\"\n    raise FileNotFoundError(msg)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter","title":"<code>seapopym.configuration.no_transport.functional_group_parameter</code>","text":"<p>This module define the data classes used to store the parameters of a functional group in the no transport model.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.MigratoryTypeParameter","title":"<code>MigratoryTypeParameter</code>","text":"<p>This data class is used to store the parameters liked to the migratory behavior of a single functional group.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.MigratoryTypeParameter--attributes","title":"Attributes","text":"<p>day_layer : int     Layer position during day. night_layer : int     Layer position during night.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>@frozen(kw_only=True)\nclass MigratoryTypeParameter:\n    \"\"\"This data class is used to store the parameters liked to the migratory behavior of a single functional group.\n\n    Attributes\n    ----------\n    day_layer : int\n        Layer position during day.\n    night_layer : int\n        Layer position during night.\n\n    \"\"\"\n\n    day_layer: int = field(\n        alias=ConfigurationLabels.day_layer,\n        converter=int,\n        metadata={\"description\": \"Layer position during day.\"},\n    )\n    night_layer: int = field(\n        alias=ConfigurationLabels.night_layer,\n        converter=int,\n        metadata={\"description\": \"Layer position during night.\"},\n    )\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalTypeParameter","title":"<code>FunctionalTypeParameter</code>","text":"<p>This data class is used to store the parameters linked to the relation between temperature and functional group.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalTypeParameter--attributes","title":"Attributes","text":"<p>lambda_temperature_0 : pint.Quantity     Value of lambda when temperature is 0\u00b0C (1/day). gamma_lambda_temperature : pint.Quantity     Rate of the inverse of the mortality (1/degC). tr_0 : pint.Quantity     Maximum value of the recruitment age (i.e. when temperature is 0\u00b0C) (day). gamma_tr : pint.Quantity     Sensibility of recruitment age to temperature (1/degC).</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>@frozen(kw_only=True)\nclass FunctionalTypeParameter:\n    \"\"\"This data class is used to store the parameters linked to the relation between temperature and functional group.\n\n    Attributes\n    ----------\n    lambda_temperature_0 : pint.Quantity\n        Value of lambda when temperature is 0\u00b0C (1/day).\n    gamma_lambda_temperature : pint.Quantity\n        Rate of the inverse of the mortality (1/degC).\n    tr_0 : pint.Quantity\n        Maximum value of the recruitment age (i.e. when temperature is 0\u00b0C) (day).\n    gamma_tr : pint.Quantity\n        Sensibility of recruitment age to temperature (1/degC).\n\n    \"\"\"\n\n    lambda_temperature_0: pint.Quantity = field(\n        alias=ConfigurationLabels.lambda_temperature_0,\n        converter=partial(verify_parameter_init, unit=\"1/day\", parameter_name=ConfigurationLabels.lambda_temperature_0),\n        validator=validators.ge(0),\n        metadata={\"description\": \"Value of lambda when temperature is 0\u00b0C.\"},\n    )\n    gamma_lambda_temperature: pint.Quantity = field(\n        alias=ConfigurationLabels.gamma_lambda_temperature,\n        converter=partial(\n            verify_parameter_init, unit=\"1/degC\", parameter_name=ConfigurationLabels.gamma_lambda_temperature\n        ),\n        validator=validators.gt(0),\n        metadata={\"description\": \"Rate of the inverse of the mortality.\"},\n    )\n    tr_0: pint.Quantity = field(\n        alias=ConfigurationLabels.tr_0,\n        converter=partial(verify_parameter_init, unit=\"day\", parameter_name=ConfigurationLabels.tr_0),\n        validator=validators.ge(0),\n        metadata={\"description\": \"Maximum value of the recruitment age (i.e. when temperature is 0\u00b0C).\"},\n    )\n    gamma_tr: pint.Quantity = field(\n        alias=ConfigurationLabels.gamma_tr,\n        converter=partial(verify_parameter_init, unit=\"1/degC\", parameter_name=ConfigurationLabels.gamma_tr),\n        validator=validators.lt(0),\n        metadata={\"description\": \"Sensibility of recruitment age to temperature.\"},\n    )\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit","title":"<code>FunctionalGroupUnit</code>","text":"<p>Represent a functional group.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit--attributes","title":"Attributes","text":"<p>name : str     The name of the functional group. energy_transfert : pint.Quantity     Energy transfert coefficient between primary production and functional group. functional_type : FunctionalTypeParameter     Parameters linked to the relation between temperature and the functional group. migratory_type : MigratoryTypeParameter     Parameters linked to the migratory behavior of the functional group. cohort_timestep : list[int] | None     The number of timesteps in the cohort. Useful for cohorts aggregation. Last timestep must be 1.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>@frozen(kw_only=True)\nclass FunctionalGroupUnit:\n    \"\"\"Represent a functional group.\n\n    Attributes\n    ----------\n    name : str\n        The name of the functional group.\n    energy_transfert : pint.Quantity\n        Energy transfert coefficient between primary production and functional group.\n    functional_type : FunctionalTypeParameter\n        Parameters linked to the relation between temperature and the functional group.\n    migratory_type : MigratoryTypeParameter\n        Parameters linked to the migratory behavior of the functional group.\n    cohort_timestep : list[int] | None\n        The number of timesteps in the cohort. Useful for cohorts aggregation. Last timestep must be 1.\n\n    \"\"\"\n\n    name: str = field(\n        metadata={\"description\": \"The name of the functional group.\"},\n        alias=ConfigurationLabels.fgroup_name,\n    )\n\n    energy_transfert: pint.Quantity = field(\n        alias=ConfigurationLabels.energy_transfert,\n        converter=partial(\n            verify_parameter_init, unit=\"dimensionless\", parameter_name=ConfigurationLabels.energy_transfert\n        ),\n        validator=[validators.ge(0), validators.le(1)],\n        metadata={\"description\": \"Energy transfert coefficient between primary production and functional group.\"},\n    )\n\n    functional_type: FunctionalTypeParameter = field(\n        validator=validators.instance_of(FunctionalTypeParameter),\n        metadata={\"description\": \"Parameters linked to the relation between temperature and the functional group.\"},\n    )\n\n    migratory_type: MigratoryTypeParameter = field(\n        validator=validators.instance_of(MigratoryTypeParameter),\n        metadata={\"description\": \"Parameters linked to the migratory behavior of the functional group.\"},\n    )\n\n    cohort_timestep: list[int] | None = field(\n        default=None,\n        metadata={\n            \"description\": (\n                \"The number of timesteps in the cohort. Useful for cohorts aggregation. Last timestep must be 1.\"\n            )\n        },\n    )\n\n    @cohort_timestep.validator\n    def check_cohort_timestep(self: FunctionalGroupUnit, attribute: str, value: list[int]) -&gt; None:\n        \"\"\"Check that the last cohort is equal to 1.\n\n        Parameters\n        ----------\n        attribute : str\n            The attribute name.\n        value : list[int]\n            The value of the attribute.\n\n        Raises\n        ------\n        TypeError\n            If value is not a list of integers or None.\n        ValueError\n            If the last element of the list is not 1.\n\n        \"\"\"\n        if not isinstance(value, Iterable | None):\n            msg = f\"The {attribute.name} must be a list of integers or None.\"\n            raise TypeError(msg)\n        if value is not None and value[-1] != 1:\n            msg = \"The last cohort timestep must be equal to 1.\"\n            raise ValueError(msg)\n\n    def update_cohort_timestep(self: FunctionalGroupUnit, timestep: pint.Quantity) -&gt; np.ndarray[pint.Quantity]:\n        \"\"\"Update the cohorts timesteps.\n\n        The last cohort is always one timestep long and has an age equal to tr_0,\n        which represents the maximum age of the pre-production in the coldest water conditions.\n\n        Parameters\n        ----------\n        timestep : pint.Quantity\n            The model timestep.\n\n        Returns\n        -------\n        np.ndarray\n            Array of timesteps for each cohort.\n\n        Raises\n        ------\n        ValueError\n            If no valid timesteps are found.\n\n        \"\"\"\n\n        def initialize_cohort_timestep() -&gt; np.ndarray[pint.Quantity]:\n            max_age = self.functional_type.tr_0\n            nb_timesteps = int(np.ceil(max_age / timestep))\n            return np.ones(nb_timesteps)\n\n        def check_validity() -&gt; np.ndarray[pint.Quantity]:\n            cumsum_timesteps = np.cumsum(self.cohort_timestep) * timestep\n            valid_mask = cumsum_timesteps &lt; self.functional_type.tr_0\n            if not valid_mask.any():\n                msg = \"No valid timesteps found. Check the input data.\"\n                raise ValueError(msg)\n            last_valid_timestep = cumsum_timesteps[valid_mask][-1]\n            remaining_timesteps = (self.functional_type.tr_0 - last_valid_timestep) // timestep\n            residual = (self.functional_type.tr_0 - last_valid_timestep) % timestep\n\n            if residual == 0:\n                to_concat = [remaining_timesteps - 1, 1] if remaining_timesteps &gt; 1 else [1]\n            elif remaining_timesteps == 0:\n                to_concat = [1]\n            else:\n                to_concat = [remaining_timesteps, 1]\n\n            valid_cohort_timestep = np.concatenate((np.array(self.cohort_timestep)[valid_mask], to_concat), dtype=int)\n\n            if not np.array_equal(valid_cohort_timestep, self.cohort_timestep):\n                message = (\n                    f\"The cohorts timesteps {self.cohort_timestep} are not valid. According to the values provided, \"\n                    f\"the cohort_timestep is set to {valid_cohort_timestep}.\"\n                )\n                logger.warning(message)\n            return valid_cohort_timestep\n\n        if self.cohort_timestep is None:\n            return initialize_cohort_timestep()\n        return check_validity()\n\n    def age_to_dataset(self: FunctionalGroupUnit, timestep: int) -&gt; xr.Dataset:\n        \"\"\"Computes the mean, minimum, and maximum age of the cohorts at each timestep.\n\n        The last cohort is always one timestep long and has an age equal to tr_0,\n        which represents the maximum age of the pre-production in the coldest water conditions.\n\n        Parameters\n        ----------\n        timestep : int\n            The model timestep duration (in days).\n\n        Returns\n        -------\n        xr.Dataset\n            Dataset containing cohort age statistics (mean, min, max, number of timesteps).\n\n        \"\"\"\n        timesteps_number = self.update_cohort_timestep(timestep)\n\n        cohort_index = create_cohort_coordinate(np.arange(0, len(timesteps_number), 1, dtype=int))\n        max_timestep = np.cumsum(timesteps_number)\n        min_timestep = max_timestep - (np.array(timesteps_number) - 1)\n        mean_timestep = (max_timestep + min_timestep) / 2\n\n        data_vars = {\n            ConfigurationLabels.timesteps_number: (\n                (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n                np.array([timesteps_number]) * timestep,\n                {\n                    \"description\": (\n                        \"The number of timesteps represented in the cohort. If there is no aggregation, all values are \"\n                        \"equal to 1.\"\n                    ),\n                    \"units\": \"day\",\n                },\n            ),\n            ConfigurationLabels.min_timestep: (\n                (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n                np.array([min_timestep]) * timestep,\n                {\"description\": \"The minimum timestep index.\", \"units\": \"day\"},\n            ),\n            ConfigurationLabels.max_timestep: (\n                (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n                np.array([max_timestep]) * timestep,\n                {\"description\": \"The maximum timestep index.\", \"units\": \"day\"},\n            ),\n            ConfigurationLabels.mean_timestep: (\n                (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n                np.array([mean_timestep]) * timestep,\n                {\"description\": \"The mean timestep index.\", \"units\": \"day\"},\n            ),\n        }\n\n        return xr.Dataset(\n            coords={CoordinatesLabels.cohort: cohort_index},\n            data_vars=data_vars,\n        )\n\n    @cached_property\n    def parameter_to_dataset(self) -&gt; xr.Dataset:\n        \"\"\"Return the parameters of the functional group as a Dataset.\n\n        This is used to create the SeapoPymState.\n\n        Returns\n        -------\n        xr.Dataset\n            Dataset containing functional group parameters.\n\n        \"\"\"\n        parameters = {\n            ConfigurationLabels.fgroup_name: self.name,\n            ConfigurationLabels.energy_transfert: self.energy_transfert,\n            **asdict(self.functional_type, recurse=False),\n            **asdict(self.migratory_type, recurse=False),\n        }\n        return xr.Dataset(parameters)\n\n    def to_dataset(self: FunctionalGroupUnit, timestep: int) -&gt; xr.Dataset:\n        \"\"\"Create the dataset of the functional group.\n\n        It contains the parameters of the functional group and the age of the cohorts.\n\n        Parameters\n        ----------\n        timestep : int\n            The model timestep duration.\n\n        Returns\n        -------\n        xr.Dataset\n            Dataset combining parameters and cohort age information.\n\n        \"\"\"\n        return xr.merge([self.parameter_to_dataset, self.age_to_dataset(timestep)])\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.parameter_to_dataset","title":"<code>parameter_to_dataset</code>  <code>cached</code> <code>property</code>","text":"<p>Return the parameters of the functional group as a Dataset.</p> <p>This is used to create the SeapoPymState.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.parameter_to_dataset--returns","title":"Returns","text":"<p>xr.Dataset     Dataset containing functional group parameters.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.check_cohort_timestep","title":"<code>check_cohort_timestep(attribute, value)</code>","text":"<p>Check that the last cohort is equal to 1.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.check_cohort_timestep--parameters","title":"Parameters","text":"<p>attribute : str     The attribute name. value : list[int]     The value of the attribute.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.check_cohort_timestep--raises","title":"Raises","text":"<p>TypeError     If value is not a list of integers or None. ValueError     If the last element of the list is not 1.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>@cohort_timestep.validator\ndef check_cohort_timestep(self: FunctionalGroupUnit, attribute: str, value: list[int]) -&gt; None:\n    \"\"\"Check that the last cohort is equal to 1.\n\n    Parameters\n    ----------\n    attribute : str\n        The attribute name.\n    value : list[int]\n        The value of the attribute.\n\n    Raises\n    ------\n    TypeError\n        If value is not a list of integers or None.\n    ValueError\n        If the last element of the list is not 1.\n\n    \"\"\"\n    if not isinstance(value, Iterable | None):\n        msg = f\"The {attribute.name} must be a list of integers or None.\"\n        raise TypeError(msg)\n    if value is not None and value[-1] != 1:\n        msg = \"The last cohort timestep must be equal to 1.\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.update_cohort_timestep","title":"<code>update_cohort_timestep(timestep)</code>","text":"<p>Update the cohorts timesteps.</p> <p>The last cohort is always one timestep long and has an age equal to tr_0, which represents the maximum age of the pre-production in the coldest water conditions.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.update_cohort_timestep--parameters","title":"Parameters","text":"<p>timestep : pint.Quantity     The model timestep.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.update_cohort_timestep--returns","title":"Returns","text":"<p>np.ndarray     Array of timesteps for each cohort.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.update_cohort_timestep--raises","title":"Raises","text":"<p>ValueError     If no valid timesteps are found.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>def update_cohort_timestep(self: FunctionalGroupUnit, timestep: pint.Quantity) -&gt; np.ndarray[pint.Quantity]:\n    \"\"\"Update the cohorts timesteps.\n\n    The last cohort is always one timestep long and has an age equal to tr_0,\n    which represents the maximum age of the pre-production in the coldest water conditions.\n\n    Parameters\n    ----------\n    timestep : pint.Quantity\n        The model timestep.\n\n    Returns\n    -------\n    np.ndarray\n        Array of timesteps for each cohort.\n\n    Raises\n    ------\n    ValueError\n        If no valid timesteps are found.\n\n    \"\"\"\n\n    def initialize_cohort_timestep() -&gt; np.ndarray[pint.Quantity]:\n        max_age = self.functional_type.tr_0\n        nb_timesteps = int(np.ceil(max_age / timestep))\n        return np.ones(nb_timesteps)\n\n    def check_validity() -&gt; np.ndarray[pint.Quantity]:\n        cumsum_timesteps = np.cumsum(self.cohort_timestep) * timestep\n        valid_mask = cumsum_timesteps &lt; self.functional_type.tr_0\n        if not valid_mask.any():\n            msg = \"No valid timesteps found. Check the input data.\"\n            raise ValueError(msg)\n        last_valid_timestep = cumsum_timesteps[valid_mask][-1]\n        remaining_timesteps = (self.functional_type.tr_0 - last_valid_timestep) // timestep\n        residual = (self.functional_type.tr_0 - last_valid_timestep) % timestep\n\n        if residual == 0:\n            to_concat = [remaining_timesteps - 1, 1] if remaining_timesteps &gt; 1 else [1]\n        elif remaining_timesteps == 0:\n            to_concat = [1]\n        else:\n            to_concat = [remaining_timesteps, 1]\n\n        valid_cohort_timestep = np.concatenate((np.array(self.cohort_timestep)[valid_mask], to_concat), dtype=int)\n\n        if not np.array_equal(valid_cohort_timestep, self.cohort_timestep):\n            message = (\n                f\"The cohorts timesteps {self.cohort_timestep} are not valid. According to the values provided, \"\n                f\"the cohort_timestep is set to {valid_cohort_timestep}.\"\n            )\n            logger.warning(message)\n        return valid_cohort_timestep\n\n    if self.cohort_timestep is None:\n        return initialize_cohort_timestep()\n    return check_validity()\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.age_to_dataset","title":"<code>age_to_dataset(timestep)</code>","text":"<p>Computes the mean, minimum, and maximum age of the cohorts at each timestep.</p> <p>The last cohort is always one timestep long and has an age equal to tr_0, which represents the maximum age of the pre-production in the coldest water conditions.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.age_to_dataset--parameters","title":"Parameters","text":"<p>timestep : int     The model timestep duration (in days).</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.age_to_dataset--returns","title":"Returns","text":"<p>xr.Dataset     Dataset containing cohort age statistics (mean, min, max, number of timesteps).</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>def age_to_dataset(self: FunctionalGroupUnit, timestep: int) -&gt; xr.Dataset:\n    \"\"\"Computes the mean, minimum, and maximum age of the cohorts at each timestep.\n\n    The last cohort is always one timestep long and has an age equal to tr_0,\n    which represents the maximum age of the pre-production in the coldest water conditions.\n\n    Parameters\n    ----------\n    timestep : int\n        The model timestep duration (in days).\n\n    Returns\n    -------\n    xr.Dataset\n        Dataset containing cohort age statistics (mean, min, max, number of timesteps).\n\n    \"\"\"\n    timesteps_number = self.update_cohort_timestep(timestep)\n\n    cohort_index = create_cohort_coordinate(np.arange(0, len(timesteps_number), 1, dtype=int))\n    max_timestep = np.cumsum(timesteps_number)\n    min_timestep = max_timestep - (np.array(timesteps_number) - 1)\n    mean_timestep = (max_timestep + min_timestep) / 2\n\n    data_vars = {\n        ConfigurationLabels.timesteps_number: (\n            (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n            np.array([timesteps_number]) * timestep,\n            {\n                \"description\": (\n                    \"The number of timesteps represented in the cohort. If there is no aggregation, all values are \"\n                    \"equal to 1.\"\n                ),\n                \"units\": \"day\",\n            },\n        ),\n        ConfigurationLabels.min_timestep: (\n            (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n            np.array([min_timestep]) * timestep,\n            {\"description\": \"The minimum timestep index.\", \"units\": \"day\"},\n        ),\n        ConfigurationLabels.max_timestep: (\n            (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n            np.array([max_timestep]) * timestep,\n            {\"description\": \"The maximum timestep index.\", \"units\": \"day\"},\n        ),\n        ConfigurationLabels.mean_timestep: (\n            (CoordinatesLabels.functional_group, CoordinatesLabels.cohort),\n            np.array([mean_timestep]) * timestep,\n            {\"description\": \"The mean timestep index.\", \"units\": \"day\"},\n        ),\n    }\n\n    return xr.Dataset(\n        coords={CoordinatesLabels.cohort: cohort_index},\n        data_vars=data_vars,\n    )\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.to_dataset","title":"<code>to_dataset(timestep)</code>","text":"<p>Create the dataset of the functional group.</p> <p>It contains the parameters of the functional group and the age of the cohorts.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.to_dataset--parameters","title":"Parameters","text":"<p>timestep : int     The model timestep duration.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupUnit.to_dataset--returns","title":"Returns","text":"<p>xr.Dataset     Dataset combining parameters and cohort age information.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>def to_dataset(self: FunctionalGroupUnit, timestep: int) -&gt; xr.Dataset:\n    \"\"\"Create the dataset of the functional group.\n\n    It contains the parameters of the functional group and the age of the cohorts.\n\n    Parameters\n    ----------\n    timestep : int\n        The model timestep duration.\n\n    Returns\n    -------\n    xr.Dataset\n        Dataset combining parameters and cohort age information.\n\n    \"\"\"\n    return xr.merge([self.parameter_to_dataset, self.age_to_dataset(timestep)])\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupParameter","title":"<code>FunctionalGroupParameter</code>","text":"<p>This data class is used to store the parameters of all functional groups.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>@frozen(kw_only=True)\nclass FunctionalGroupParameter:\n    \"\"\"This data class is used to store the parameters of all functional groups.\"\"\"\n\n    functional_group: list[FunctionalGroupUnit] = field(metadata={\"description\": \"List of all functional groups.\"})\n\n    @functional_group.validator\n    def are_all_instance_of_functional_group_unit(\n        self: FunctionalGroupParameter, attribute: str, value: list[FunctionalGroupUnit]\n    ) -&gt; None:\n        \"\"\"This method is used to check the consistency of the functional groups.\"\"\"\n        if not all(isinstance(fgroup, FunctionalGroupUnit) for fgroup in value):\n            msg = \"All the functional groups must be instance of FunctionalGroupUnit.\"\n            raise TypeError(msg)\n\n    def to_dataset(self: FunctionalGroupParameter, timestep: int) -&gt; xr.Dataset:\n        \"\"\"Convert all functional groups parameters to a single xarray Dataset.\n\n        Parameters\n        ----------\n        timestep : int\n            The model timestep duration.\n\n        Returns\n        -------\n        xr.Dataset\n            Dataset containing parameters for all functional groups concatenated along the functional_group dimension.\n\n        \"\"\"\n        all_dataset = [fgroup.to_dataset(timestep) for fgroup in self.functional_group]\n\n        coordinates = xr.DataArray(\n            data=range(len(all_dataset)),\n            dims=[CoordinatesLabels.functional_group],\n            attrs=functional_group_desc(range(len(all_dataset)), [fgroup.name for fgroup in self.functional_group]),\n        )\n\n        return xr.concat(all_dataset, dim=coordinates, combine_attrs=\"no_conflicts\", join=\"outer\", data_vars=\"all\")\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupParameter.are_all_instance_of_functional_group_unit","title":"<code>are_all_instance_of_functional_group_unit(attribute, value)</code>","text":"<p>This method is used to check the consistency of the functional groups.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>@functional_group.validator\ndef are_all_instance_of_functional_group_unit(\n    self: FunctionalGroupParameter, attribute: str, value: list[FunctionalGroupUnit]\n) -&gt; None:\n    \"\"\"This method is used to check the consistency of the functional groups.\"\"\"\n    if not all(isinstance(fgroup, FunctionalGroupUnit) for fgroup in value):\n        msg = \"All the functional groups must be instance of FunctionalGroupUnit.\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupParameter.to_dataset","title":"<code>to_dataset(timestep)</code>","text":"<p>Convert all functional groups parameters to a single xarray Dataset.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupParameter.to_dataset--parameters","title":"Parameters","text":"<p>timestep : int     The model timestep duration.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.functional_group_parameter.FunctionalGroupParameter.to_dataset--returns","title":"Returns","text":"<p>xr.Dataset     Dataset containing parameters for all functional groups concatenated along the functional_group dimension.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/functional_group_parameter.py</code> <pre><code>def to_dataset(self: FunctionalGroupParameter, timestep: int) -&gt; xr.Dataset:\n    \"\"\"Convert all functional groups parameters to a single xarray Dataset.\n\n    Parameters\n    ----------\n    timestep : int\n        The model timestep duration.\n\n    Returns\n    -------\n    xr.Dataset\n        Dataset containing parameters for all functional groups concatenated along the functional_group dimension.\n\n    \"\"\"\n    all_dataset = [fgroup.to_dataset(timestep) for fgroup in self.functional_group]\n\n    coordinates = xr.DataArray(\n        data=range(len(all_dataset)),\n        dims=[CoordinatesLabels.functional_group],\n        attrs=functional_group_desc(range(len(all_dataset)), [fgroup.name for fgroup in self.functional_group]),\n    )\n\n    return xr.concat(all_dataset, dim=coordinates, combine_attrs=\"no_conflicts\", join=\"outer\", data_vars=\"all\")\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.kernel_parameter","title":"<code>seapopym.configuration.no_transport.kernel_parameter</code>","text":"<p>This module defines the kernel parameters which are used to modify behaviour of kernel functions.</p> <p>These meta-parameters are integrated in the model state and used in kernel functions.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.kernel_parameter.KernelParameter","title":"<code>KernelParameter</code>","text":"<p>This data class is used to store the parameters of the kernel.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.kernel_parameter.KernelParameter--attributes","title":"Attributes","text":"<p>angle_horizon_sun : Number     The angle between the horizon and the sun in degrees. Default is 0.0. compute_initial_conditions : bool     If True, the initial conditions are computed. Default is False. compute_preproduction : bool     If True, the pre-production is computed. Default is False.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/kernel_parameter.py</code> <pre><code>@frozen(kw_only=True)\nclass KernelParameter:\n    \"\"\"This data class is used to store the parameters of the kernel.\n\n    Attributes\n    ----------\n    angle_horizon_sun : Number\n        The angle between the horizon and the sun in degrees. Default is 0.0.\n    compute_initial_conditions : bool\n        If True, the initial conditions are computed. Default is False.\n    compute_preproduction : bool\n        If True, the pre-production is computed. Default is False.\n\n    \"\"\"\n\n    angle_horizon_sun: Number = field(\n        alias=ConfigurationLabels.angle_horizon_sun,\n        default=0.0,\n        metadata={\"description\": \"The angle between the horizon and the sun in degrees.\"},\n    )\n\n    compute_initial_conditions: bool = field(\n        alias=ConfigurationLabels.compute_initial_conditions,\n        default=False,\n        metadata={\"description\": \"If True, the initial conditions are computed.\"},\n    )\n\n    compute_preproduction: bool = field(\n        alias=ConfigurationLabels.compute_preproduction,\n        default=False,\n        metadata={\"description\": \"If True, the pre-production is computed.\"},\n    )\n\n    def __attrs_post_init__(self) -&gt; None:\n        \"\"\"Post-initialization processing.\"\"\"\n        if self.compute_initial_conditions and self.compute_preproduction:\n            msg = (\n                \"Select only one of compute_initial_conditions or compute_preproduction.\"\n                \"As compute_initial_conditions is included in compute_preproduction, \"\n            )\n            raise ValueError(msg)\n\n    def to_dataset(self) -&gt; xr.Dataset:\n        \"\"\"Convert the kernel parameters to a dataset.\n\n        Returns\n        -------\n        xr.Dataset\n            Dataset containing the kernel parameters.\n\n        \"\"\"\n        return xr.Dataset(\n            {\n                ConfigurationLabels.angle_horizon_sun: self.angle_horizon_sun,\n                ConfigurationLabels.compute_initial_conditions: self.compute_initial_conditions,\n                ConfigurationLabels.compute_preproduction: self.compute_preproduction,\n            }\n        )\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.kernel_parameter.KernelParameter.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Post-initialization processing.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/kernel_parameter.py</code> <pre><code>def __attrs_post_init__(self) -&gt; None:\n    \"\"\"Post-initialization processing.\"\"\"\n    if self.compute_initial_conditions and self.compute_preproduction:\n        msg = (\n            \"Select only one of compute_initial_conditions or compute_preproduction.\"\n            \"As compute_initial_conditions is included in compute_preproduction, \"\n        )\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.kernel_parameter.KernelParameter.to_dataset","title":"<code>to_dataset()</code>","text":"<p>Convert the kernel parameters to a dataset.</p>"},{"location":"api/seapopym/#seapopym.configuration.no_transport.kernel_parameter.KernelParameter.to_dataset--returns","title":"Returns","text":"<p>xr.Dataset     Dataset containing the kernel parameters.</p> Source code in <code>packages/seapopym/src/seapopym/configuration/no_transport/kernel_parameter.py</code> <pre><code>def to_dataset(self) -&gt; xr.Dataset:\n    \"\"\"Convert the kernel parameters to a dataset.\n\n    Returns\n    -------\n    xr.Dataset\n        Dataset containing the kernel parameters.\n\n    \"\"\"\n    return xr.Dataset(\n        {\n            ConfigurationLabels.angle_horizon_sun: self.angle_horizon_sun,\n            ConfigurationLabels.compute_initial_conditions: self.compute_initial_conditions,\n            ConfigurationLabels.compute_preproduction: self.compute_preproduction,\n        }\n    )\n</code></pre>"},{"location":"api/seapopym/#standard","title":"Standard","text":""},{"location":"api/seapopym/#coordinates","title":"Coordinates","text":""},{"location":"api/seapopym/#seapopym.standard.coordinates","title":"<code>seapopym.standard.coordinates</code>","text":"<p>Re-exports coordinate factory functions from coordinate_authority module.</p> <p>This module provides backwards compatibility by re-exporting functions from the coordinate_authority module. For new code, prefer importing directly from seapopym.standard.coordinate_authority or using the CoordinateAuthority class.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_cohort","title":"<code>new_cohort(cohort_data)</code>","text":"<p>Create a new cohort coordinate.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_cohort--parameters","title":"Parameters","text":"<p>cohort_data : Iterable     Array of cohort values.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_cohort--returns","title":"Returns","text":"<p>xr.DataArray     The cohort coordinate DataArray with attributes.</p> Source code in <code>packages/seapopym/src/seapopym/standard/coordinate_authority.py</code> <pre><code>def create_cohort_coordinate(cohort_data: Iterable) -&gt; xr.DataArray:\n    \"\"\"Create a new cohort coordinate.\n\n    Parameters\n    ----------\n    cohort_data : Iterable\n        Array of cohort values.\n\n    Returns\n    -------\n    xr.DataArray\n        The cohort coordinate DataArray with attributes.\n\n    \"\"\"\n    attributs = {\"long_name\": \"cohort\", \"standard_name\": \"cohort\"}\n    return xr.DataArray(\n        coords=[(\"cohort\", cohort_data, attributs)],\n        dims=[\"cohort\"],\n    ).coords[\"cohort\"]\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_latitude","title":"<code>new_latitude(latitude_data)</code>","text":"<p>Create a new latitude coordinate with standardized Y name.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_latitude--parameters","title":"Parameters","text":"<p>latitude_data : np.ndarray     Array of latitude values.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_latitude--returns","title":"Returns","text":"<p>xr.DataArray     The latitude coordinate DataArray with attributes.</p> Source code in <code>packages/seapopym/src/seapopym/standard/coordinate_authority.py</code> <pre><code>def create_latitude_coordinate(latitude_data: np.ndarray) -&gt; xr.DataArray:\n    \"\"\"Create a new latitude coordinate with standardized Y name.\n\n    Parameters\n    ----------\n    latitude_data : np.ndarray\n        Array of latitude values.\n\n    Returns\n    -------\n    xr.DataArray\n        The latitude coordinate DataArray with attributes.\n\n    \"\"\"\n    attributs = {\"long_name\": \"latitude\", \"standard_name\": \"latitude\", \"units\": \"degrees_north\", \"axis\": \"Y\"}\n    return xr.DataArray(\n        coords=[(\"Y\", latitude_data, attributs)],\n        dims=[\"Y\"],\n    ).coords[\"Y\"]\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_layer","title":"<code>new_layer(layer_data=None)</code>","text":"<p>Create a new layer coordinate.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_layer--parameters","title":"Parameters","text":"<p>layer_data : Iterable | None, optional     Array of layer values. If None, defaults are used from SeaLayers.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_layer--returns","title":"Returns","text":"<p>xr.DataArray     The layer coordinate DataArray with attributes.</p> Source code in <code>packages/seapopym/src/seapopym/standard/coordinate_authority.py</code> <pre><code>def create_layer_coordinate(layer_data: Iterable | None = None) -&gt; xr.DataArray:\n    \"\"\"Create a new layer coordinate.\n\n    Parameters\n    ----------\n    layer_data : Iterable | None, optional\n        Array of layer values. If None, defaults are used from SeaLayers.\n\n    Returns\n    -------\n    xr.DataArray\n        The layer coordinate DataArray with attributes.\n\n    \"\"\"\n    if layer_data is None:\n        layer_data = [layer.depth for layer in SeaLayers]\n    attributs = {\n        \"long_name\": \"layer\",\n        \"standard_name\": \"layer\",\n        \"positive\": \"down\",\n        \"axis\": \"Z\",\n        \"flag_values\": str(layer_data),\n        \"flag_meanings\": \" \".join([layer.standard_name for layer in SeaLayers]),\n    }\n    return xr.DataArray(coords=((\"Z\", layer_data, attributs),), dims=[\"Z\"]).coords[\"Z\"]\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_longitude","title":"<code>new_longitude(longitude_data)</code>","text":"<p>Create a new longitude coordinate with standardized X name.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_longitude--parameters","title":"Parameters","text":"<p>longitude_data : Iterable     Array of longitude values.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_longitude--returns","title":"Returns","text":"<p>xr.DataArray     The longitude coordinate DataArray with attributes.</p> Source code in <code>packages/seapopym/src/seapopym/standard/coordinate_authority.py</code> <pre><code>def create_longitude_coordinate(longitude_data: Iterable) -&gt; xr.DataArray:\n    \"\"\"Create a new longitude coordinate with standardized X name.\n\n    Parameters\n    ----------\n    longitude_data : Iterable\n        Array of longitude values.\n\n    Returns\n    -------\n    xr.DataArray\n        The longitude coordinate DataArray with attributes.\n\n    \"\"\"\n    attributs = {\"long_name\": \"longitude\", \"standard_name\": \"longitude\", \"units\": \"degrees_east\", \"axis\": \"X\"}\n    return xr.DataArray(\n        coords=[(\"X\", longitude_data, attributs)],\n        dims=[\"X\"],\n    ).coords[\"X\"]\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_time","title":"<code>new_time(time_data)</code>","text":"<p>Create a new time coordinate with standardized T name.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_time--parameters","title":"Parameters","text":"<p>time_data : Iterable     Array of time values.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.new_time--returns","title":"Returns","text":"<p>xr.DataArray     The time coordinate DataArray with attributes.</p> Source code in <code>packages/seapopym/src/seapopym/standard/coordinate_authority.py</code> <pre><code>def create_time_coordinate(time_data: Iterable) -&gt; xr.DataArray:\n    \"\"\"Create a new time coordinate with standardized T name.\n\n    Parameters\n    ----------\n    time_data : Iterable\n        Array of time values.\n\n    Returns\n    -------\n    xr.DataArray\n        The time coordinate DataArray with attributes.\n\n    \"\"\"\n    return xr.DataArray(\n        coords=[(\"T\", time_data, {\"long_name\": \"time\", \"standard_name\": \"time\", \"axis\": \"T\"})], dims=[\"T\"]\n    ).coords[\"T\"]\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.coordinates.reorder_dims","title":"<code>reorder_dims(data)</code>","text":"<p>Follow the standard order of dimensions for a xarray.Dataset or xarray.DataArray.</p> <p>This is a convenience wrapper around CoordinatesLabels.order_data(). For new code, prefer using CoordinatesLabels.order_data() directly.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.reorder_dims--parameters","title":"Parameters","text":"<p>data : xr.Dataset | xr.DataArray     The input data to reorder.</p>"},{"location":"api/seapopym/#seapopym.standard.coordinates.reorder_dims--returns","title":"Returns","text":"<p>xr.Dataset | xr.DataArray     The reordered data.</p> Source code in <code>packages/seapopym/src/seapopym/standard/coordinates.py</code> <pre><code>def reorder_dims(data: xr.Dataset | xr.DataArray) -&gt; xr.Dataset | xr.DataArray:\n    \"\"\"Follow the standard order of dimensions for a xarray.Dataset or xarray.DataArray.\n\n    This is a convenience wrapper around CoordinatesLabels.order_data().\n    For new code, prefer using CoordinatesLabels.order_data() directly.\n\n    Parameters\n    ----------\n    data : xr.Dataset | xr.DataArray\n        The input data to reorder.\n\n    Returns\n    -------\n    xr.Dataset | xr.DataArray\n        The reordered data.\n\n    \"\"\"\n    return CoordinatesLabels.order_data(data)\n</code></pre>"},{"location":"api/seapopym/#units","title":"Units","text":""},{"location":"api/seapopym/#seapopym.standard.units","title":"<code>seapopym.standard.units</code>","text":"<p>A module for handling units in the forcing data following the CF conventions.</p>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsLabels","title":"<code>StandardUnitsLabels</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Unit of measurement as used in the model.</p>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsLabels--attributes","title":"Attributes","text":"<p>height : str     Unit for height/distance (meter). weight : str     Unit for weight/mass (gram). temperature : str     Unit for temperature (celsius). time : str     Unit for time (day). biomass : str     Unit for biomass density (gram / meter2). production : str     Unit for production rate (gram / meter2 / day). acidity : str     Unit for acidity (dimensionless). concentration : str     Unit for concentration (gram / meter**3).</p> Source code in <code>packages/seapopym/src/seapopym/standard/units.py</code> <pre><code>class StandardUnitsLabels(StrEnum):\n    \"\"\"Unit of measurement as used in the model.\n\n    Attributes\n    ----------\n    height : str\n        Unit for height/distance (meter).\n    weight : str\n        Unit for weight/mass (gram).\n    temperature : str\n        Unit for temperature (celsius).\n    time : str\n        Unit for time (day).\n    biomass : str\n        Unit for biomass density (gram / meter**2).\n    production : str\n        Unit for production rate (gram / meter**2 / day).\n    acidity : str\n        Unit for acidity (dimensionless).\n    concentration : str\n        Unit for concentration (gram / meter**3).\n\n    \"\"\"\n\n    height = \"meter\"\n    weight = \"gram\"\n    temperature = \"celsius\"\n    time = \"day\"\n    biomass = \"gram / meter**2\"\n    production = \"gram / meter**2 / day\"\n    acidity = \"dimensionless\"\n    concentration = \"gram / meter**3\"\n\n    def __init__(self: StandardUnitsLabels, unit_as_str: str) -&gt; None:\n        \"\"\"Prevent the instantiation of this class.\n\n        Parameters\n        ----------\n        unit_as_str : str\n            The string representation of the unit.\n\n        \"\"\"\n        self._units = pint.application_registry(unit_as_str).units\n\n    @property\n    def units(self: StandardUnitsLabels) -&gt; pint.Unit:\n        \"\"\"Convert the string unit to the equivalent pint unit.\n\n        Returns\n        -------\n        pint.Unit\n            The pint Unit object.\n\n        \"\"\"\n        return self._units\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsLabels.units","title":"<code>units</code>  <code>property</code>","text":"<p>Convert the string unit to the equivalent pint unit.</p>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsLabels.units--returns","title":"Returns","text":"<p>pint.Unit     The pint Unit object.</p>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsLabels.__init__","title":"<code>__init__(unit_as_str)</code>","text":"<p>Prevent the instantiation of this class.</p>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsLabels.__init__--parameters","title":"Parameters","text":"<p>unit_as_str : str     The string representation of the unit.</p> Source code in <code>packages/seapopym/src/seapopym/standard/units.py</code> <pre><code>def __init__(self: StandardUnitsLabels, unit_as_str: str) -&gt; None:\n    \"\"\"Prevent the instantiation of this class.\n\n    Parameters\n    ----------\n    unit_as_str : str\n        The string representation of the unit.\n\n    \"\"\"\n    self._units = pint.application_registry(unit_as_str).units\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsRegistry","title":"<code>StandardUnitsRegistry</code>","text":"<p>Centralized registry for units management and conversion.</p> <p>Provides a clean API for unit handling, formatting, and validation to replace scattered unit conversions throughout the codebase.</p> <p>This registry acts as the single source of truth for all unit operations in Seapopym, ensuring consistent unit handling across templates, kernels, and data processing functions.</p> Key Features <ul> <li>Standardized unit string formatting for xarray attributes</li> <li>Convenient attribute dictionary generation for DataArrays</li> <li>Unit compatibility validation for data objects</li> <li>Complete enumeration of supported units</li> </ul> Usage Patterns <p>Basic unit formatting:</p> <p>StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.temperature) 'degree_Celsius'</p> <p>Creating xarray attributes:</p> <p>attrs = StandardUnitsRegistry.get_unit_attrs( ...     StandardUnitsLabels.biomass, ...     long_name=\"Biomass density\", ...     standard_name=\"biomass_density\" ... )</p> <p>Template integration:</p> Thread Safety <p>All methods are static and thread-safe. No instance state is maintained.</p> Source code in <code>packages/seapopym/src/seapopym/standard/units.py</code> <pre><code>class StandardUnitsRegistry:\n    \"\"\"Centralized registry for units management and conversion.\n\n    Provides a clean API for unit handling, formatting, and validation\n    to replace scattered unit conversions throughout the codebase.\n\n    This registry acts as the single source of truth for all unit operations\n    in Seapopym, ensuring consistent unit handling across templates, kernels,\n    and data processing functions.\n\n    Key Features:\n        - Standardized unit string formatting for xarray attributes\n        - Convenient attribute dictionary generation for DataArrays\n        - Unit compatibility validation for data objects\n        - Complete enumeration of supported units\n\n    Usage Patterns:\n        Basic unit formatting:\n        &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.temperature)\n        'degree_Celsius'\n\n        Creating xarray attributes:\n        &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n        ...     StandardUnitsLabels.biomass,\n        ...     long_name=\"Biomass density\",\n        ...     standard_name=\"biomass_density\"\n        ... )\n        &gt;&gt;&gt; # Use with xarray: data_array.attrs.update(attrs)\n\n        Template integration:\n        &gt;&gt;&gt; # In template factories\n        &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n        ...     StandardUnitsLabels.production,\n        ...     standard_name=\"primary_production_rate\"\n        ... )\n\n    Thread Safety:\n        All methods are static and thread-safe. No instance state is maintained.\n    \"\"\"\n\n    @staticmethod\n    def format_unit_string(unit_label: StandardUnitsLabels) -&gt; str:\n        \"\"\"Format a unit label to standardized string representation.\n\n        Converts a StandardUnitsLabels enum value to its string representation\n        as formatted by the pint units library. This ensures consistent unit\n        formatting across all xarray attributes and CF-compliant datasets.\n\n        Args:\n            unit_label: Unit label from StandardUnitsLabels enum\n\n        Returns:\n            Formatted unit string suitable for xarray attributes.\n            Note: Pint may format units differently than the input strings\n            (e.g., 'celsius' becomes 'degree_Celsius')\n\n        Raises:\n            AttributeError: If unit_label is not a valid StandardUnitsLabels enum\n\n        Examples:\n            Basic unit formatting:\n            &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.temperature)\n            'degree_Celsius'\n            &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.time)\n            'day'\n\n            Complex compound units:\n            &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.biomass)\n            'gram / meter ** 2'\n            &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.production)\n            'gram / meter ** 2 / day'\n\n        Note:\n            This method is the recommended way to get unit strings for xarray\n            attributes, replacing direct access to StandardUnitsLabels.units\n\n        \"\"\"\n        return str(unit_label.units)\n\n    @staticmethod\n    def get_unit_attrs(unit_label: StandardUnitsLabels, **overrides: Any) -&gt; dict[str, str]:\n        \"\"\"Get standardized unit attributes for xarray DataArrays.\n\n        Creates a dictionary of attributes suitable for xarray DataArray.attrs,\n        starting with the properly formatted units and allowing additional\n        CF-compliant attributes to be specified as overrides.\n\n        Args:\n            unit_label: Unit label from StandardUnitsLabels enum\n            **overrides: Additional attributes to include or override.\n                        Common CF attributes include 'long_name', 'standard_name',\n                        'description', etc. The 'units' key can be overridden\n                        if a different unit string is needed.\n\n        Returns:\n            Dictionary with 'units' key and any additional overrides.\n            All values are strings suitable for xarray attributes.\n\n        Examples:\n            Basic usage (units only):\n            &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(StandardUnitsLabels.temperature)\n            &gt;&gt;&gt; attrs\n            {'units': 'degree_Celsius'}\n\n            With CF-compliant metadata:\n            &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n            ...     StandardUnitsLabels.biomass,\n            ...     long_name=\"Biomass density\",\n            ...     standard_name=\"biomass_density\",\n            ...     description=\"Dry weight biomass per unit area\"\n            ... )\n            &gt;&gt;&gt; attrs\n            {'units': 'gram / meter ** 2', 'long_name': 'Biomass density', ...}\n\n            Overriding units:\n            &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n            ...     StandardUnitsLabels.temperature,\n            ...     units=\"kelvin\",  # Override default celsius\n            ...     standard_name=\"sea_water_temperature\"\n            ... )\n            &gt;&gt;&gt; attrs\n            {'units': 'kelvin', 'standard_name': 'sea_water_temperature'}\n\n            Template factory usage:\n            &gt;&gt;&gt; # Common pattern in template factories\n            &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n            ...     StandardUnitsLabels.production,\n            ...     long_name=\"Primary production rate\",\n            ...     standard_name=\"net_primary_production_of_biomass_expressed_as_carbon\"\n            ... )\n\n        Note:\n            This is the recommended way to create xarray attributes with units,\n            ensuring consistency across all DataArrays in the system.\n\n        \"\"\"\n        attrs = {\"units\": StandardUnitsRegistry.format_unit_string(unit_label)}\n        attrs.update(overrides)\n        return attrs\n\n    @staticmethod\n    def validate_unit_compatibility(value: Any, expected_unit: StandardUnitsLabels) -&gt; bool:\n        \"\"\"Validate that a value has compatible units.\n\n        Performs unit compatibility validation by comparing the units attribute\n        of a value object against an expected StandardUnitsLabels enum value.\n        This validation ensures data consistency across the pipeline.\n\n        Args:\n            value: Object to validate. Must have a 'units' attribute (typically\n                  xarray DataArray, Dataset, or similar objects with units metadata)\n            expected_unit: Expected unit label from StandardUnitsLabels enum\n\n        Returns:\n            True if units match exactly, False otherwise.\n            Returns False for any objects without units or on validation errors.\n\n        Validation Logic:\n            - Checks if value has 'units' attribute\n            - Compares string representation of units for exact match\n            - Handles exceptions gracefully by returning False\n\n        Examples:\n            Validating xarray DataArray:\n            &gt;&gt;&gt; import xarray as xr\n            &gt;&gt;&gt; data = xr.DataArray([1, 2, 3], attrs={'units': 'degree_Celsius'})\n            &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n            ...     data, StandardUnitsLabels.temperature\n            ... )\n            True\n\n            Invalid units:\n            &gt;&gt;&gt; data = xr.DataArray([1, 2, 3], attrs={'units': 'kelvin'})\n            &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n            ...     data, StandardUnitsLabels.temperature\n            ... )\n            False\n\n            Missing units attribute:\n            &gt;&gt;&gt; data = xr.DataArray([1, 2, 3])  # No units\n            &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n            ...     data, StandardUnitsLabels.temperature\n            ... )\n            False\n\n            Custom objects:\n            &gt;&gt;&gt; class TemperatureData:\n            ...     def __init__(self, units_str):\n            ...         self.units = units_str\n            &gt;&gt;&gt; data = TemperatureData('degree_Celsius')\n            &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n            ...     data, StandardUnitsLabels.temperature\n            ... )\n            True\n\n        Error Handling:\n            All exceptions (AttributeError, TypeError, ValueError) are caught\n            and result in False return value. This ensures robust validation\n            even with malformed or unexpected input objects.\n\n        Future Enhancements:\n            This basic string comparison can be extended to support:\n            - Pint unit compatibility checking (e.g., celsius vs kelvin)\n            - Unit conversion compatibility\n            - Dimensional analysis validation\n\n        Note:\n            Currently performs exact string matching. Compatible but differently\n            formatted units (e.g., 'deg_C' vs 'degree_Celsius') will return False.\n\n        \"\"\"\n        try:\n            if not hasattr(value, \"units\"):\n                return False\n\n            expected_pint_unit = expected_unit.units\n            actual_units = getattr(value, \"units\", None)\n\n            if actual_units is None:\n                return False\n\n            # Basic string comparison - can be enhanced with pint compatibility checking\n            return str(actual_units) == str(expected_pint_unit)\n        except (AttributeError, TypeError, ValueError):\n            return False\n\n    @staticmethod\n    def get_supported_units() -&gt; tuple[StandardUnitsLabels, ...]:\n        \"\"\"Get all supported unit labels.\n\n        Returns a tuple containing all available StandardUnitsLabels enum values,\n        providing a complete inventory of units supported by the system.\n\n        Returns:\n            Tuple of all available StandardUnitsLabels enum values.\n            The tuple is ordered according to the enum definition.\n\n        Examples:\n            Getting all supported units:\n            &gt;&gt;&gt; units = StandardUnitsRegistry.get_supported_units()\n            &gt;&gt;&gt; len(units)\n            7\n            &gt;&gt;&gt; StandardUnitsLabels.temperature in units\n            True\n\n            Iterating over supported units:\n            &gt;&gt;&gt; for unit_label in StandardUnitsRegistry.get_supported_units():\n            ...     unit_str = StandardUnitsRegistry.format_unit_string(unit_label)\n            ...     print(f\"{unit_label.name}: {unit_str}\")\n            height: meter\n            weight: gram\n            temperature: degree_Celsius\n            ...\n\n            Validation and enumeration:\n            &gt;&gt;&gt; supported = StandardUnitsRegistry.get_supported_units()\n            &gt;&gt;&gt; user_unit = \"temperature\"  # From user input\n            &gt;&gt;&gt; if any(unit.name == user_unit for unit in supported):\n            ...     unit_label = StandardUnitsLabels[user_unit]\n            ...     attrs = StandardUnitsRegistry.get_unit_attrs(unit_label)\n\n        Use Cases:\n            - Dynamic unit validation in configuration parsing\n            - Building user interfaces with unit selection\n            - Documentation generation\n            - Testing completeness of unit handling\n\n        Note:\n            The returned tuple is immutable and reflects the current state\n            of the StandardUnitsLabels enum. Changes to the enum will be\n            automatically reflected in subsequent calls.\n\n        \"\"\"\n        return tuple(StandardUnitsLabels)\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsRegistry--use-with-xarray-data_arrayattrsupdateattrs","title":"Use with xarray: data_array.attrs.update(attrs)","text":""},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsRegistry--in-template-factories","title":"In template factories","text":"<p>attrs = StandardUnitsRegistry.get_unit_attrs( ...     StandardUnitsLabels.production, ...     standard_name=\"primary_production_rate\" ... )</p>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsRegistry.format_unit_string","title":"<code>format_unit_string(unit_label)</code>  <code>staticmethod</code>","text":"<p>Format a unit label to standardized string representation.</p> <p>Converts a StandardUnitsLabels enum value to its string representation as formatted by the pint units library. This ensures consistent unit formatting across all xarray attributes and CF-compliant datasets.</p> <p>Parameters:</p> Name Type Description Default <code>unit_label</code> <code>StandardUnitsLabels</code> <p>Unit label from StandardUnitsLabels enum</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Formatted unit string suitable for xarray attributes.</p> <code>Note</code> <code>str</code> <p>Pint may format units differently than the input strings</p> <code>str</code> <p>(e.g., 'celsius' becomes 'degree_Celsius')</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If unit_label is not a valid StandardUnitsLabels enum</p> <p>Examples:</p> <p>Basic unit formatting:</p> <pre><code>&gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.temperature)\n'degree_Celsius'\n&gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.time)\n'day'\n</code></pre> <p>Complex compound units:</p> <pre><code>&gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.biomass)\n'gram / meter ** 2'\n&gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.production)\n'gram / meter ** 2 / day'\n</code></pre> Note <p>This method is the recommended way to get unit strings for xarray attributes, replacing direct access to StandardUnitsLabels.units</p> Source code in <code>packages/seapopym/src/seapopym/standard/units.py</code> <pre><code>@staticmethod\ndef format_unit_string(unit_label: StandardUnitsLabels) -&gt; str:\n    \"\"\"Format a unit label to standardized string representation.\n\n    Converts a StandardUnitsLabels enum value to its string representation\n    as formatted by the pint units library. This ensures consistent unit\n    formatting across all xarray attributes and CF-compliant datasets.\n\n    Args:\n        unit_label: Unit label from StandardUnitsLabels enum\n\n    Returns:\n        Formatted unit string suitable for xarray attributes.\n        Note: Pint may format units differently than the input strings\n        (e.g., 'celsius' becomes 'degree_Celsius')\n\n    Raises:\n        AttributeError: If unit_label is not a valid StandardUnitsLabels enum\n\n    Examples:\n        Basic unit formatting:\n        &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.temperature)\n        'degree_Celsius'\n        &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.time)\n        'day'\n\n        Complex compound units:\n        &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.biomass)\n        'gram / meter ** 2'\n        &gt;&gt;&gt; StandardUnitsRegistry.format_unit_string(StandardUnitsLabels.production)\n        'gram / meter ** 2 / day'\n\n    Note:\n        This method is the recommended way to get unit strings for xarray\n        attributes, replacing direct access to StandardUnitsLabels.units\n\n    \"\"\"\n    return str(unit_label.units)\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsRegistry.get_unit_attrs","title":"<code>get_unit_attrs(unit_label, **overrides)</code>  <code>staticmethod</code>","text":"<p>Get standardized unit attributes for xarray DataArrays.</p> <p>Creates a dictionary of attributes suitable for xarray DataArray.attrs, starting with the properly formatted units and allowing additional CF-compliant attributes to be specified as overrides.</p> <p>Parameters:</p> Name Type Description Default <code>unit_label</code> <code>StandardUnitsLabels</code> <p>Unit label from StandardUnitsLabels enum</p> required <code>**overrides</code> <code>Any</code> <p>Additional attributes to include or override.         Common CF attributes include 'long_name', 'standard_name',         'description', etc. The 'units' key can be overridden         if a different unit string is needed.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary with 'units' key and any additional overrides.</p> <code>dict[str, str]</code> <p>All values are strings suitable for xarray attributes.</p> <p>Examples:</p> <p>Basic usage (units only):</p> <pre><code>&gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(StandardUnitsLabels.temperature)\n&gt;&gt;&gt; attrs\n{'units': 'degree_Celsius'}\n</code></pre> <p>With CF-compliant metadata:</p> <pre><code>&gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n...     StandardUnitsLabels.biomass,\n...     long_name=\"Biomass density\",\n...     standard_name=\"biomass_density\",\n...     description=\"Dry weight biomass per unit area\"\n... )\n&gt;&gt;&gt; attrs\n{'units': 'gram / meter ** 2', 'long_name': 'Biomass density', ...}\n</code></pre> <p>Overriding units:</p> <pre><code>&gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n...     StandardUnitsLabels.temperature,\n...     units=\"kelvin\",  # Override default celsius\n...     standard_name=\"sea_water_temperature\"\n... )\n&gt;&gt;&gt; attrs\n{'units': 'kelvin', 'standard_name': 'sea_water_temperature'}\n</code></pre> <p>Template factory usage:</p> <pre><code>&gt;&gt;&gt; # Common pattern in template factories\n&gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n...     StandardUnitsLabels.production,\n...     long_name=\"Primary production rate\",\n...     standard_name=\"net_primary_production_of_biomass_expressed_as_carbon\"\n... )\n</code></pre> Note <p>This is the recommended way to create xarray attributes with units, ensuring consistency across all DataArrays in the system.</p> Source code in <code>packages/seapopym/src/seapopym/standard/units.py</code> <pre><code>@staticmethod\ndef get_unit_attrs(unit_label: StandardUnitsLabels, **overrides: Any) -&gt; dict[str, str]:\n    \"\"\"Get standardized unit attributes for xarray DataArrays.\n\n    Creates a dictionary of attributes suitable for xarray DataArray.attrs,\n    starting with the properly formatted units and allowing additional\n    CF-compliant attributes to be specified as overrides.\n\n    Args:\n        unit_label: Unit label from StandardUnitsLabels enum\n        **overrides: Additional attributes to include or override.\n                    Common CF attributes include 'long_name', 'standard_name',\n                    'description', etc. The 'units' key can be overridden\n                    if a different unit string is needed.\n\n    Returns:\n        Dictionary with 'units' key and any additional overrides.\n        All values are strings suitable for xarray attributes.\n\n    Examples:\n        Basic usage (units only):\n        &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(StandardUnitsLabels.temperature)\n        &gt;&gt;&gt; attrs\n        {'units': 'degree_Celsius'}\n\n        With CF-compliant metadata:\n        &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n        ...     StandardUnitsLabels.biomass,\n        ...     long_name=\"Biomass density\",\n        ...     standard_name=\"biomass_density\",\n        ...     description=\"Dry weight biomass per unit area\"\n        ... )\n        &gt;&gt;&gt; attrs\n        {'units': 'gram / meter ** 2', 'long_name': 'Biomass density', ...}\n\n        Overriding units:\n        &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n        ...     StandardUnitsLabels.temperature,\n        ...     units=\"kelvin\",  # Override default celsius\n        ...     standard_name=\"sea_water_temperature\"\n        ... )\n        &gt;&gt;&gt; attrs\n        {'units': 'kelvin', 'standard_name': 'sea_water_temperature'}\n\n        Template factory usage:\n        &gt;&gt;&gt; # Common pattern in template factories\n        &gt;&gt;&gt; attrs = StandardUnitsRegistry.get_unit_attrs(\n        ...     StandardUnitsLabels.production,\n        ...     long_name=\"Primary production rate\",\n        ...     standard_name=\"net_primary_production_of_biomass_expressed_as_carbon\"\n        ... )\n\n    Note:\n        This is the recommended way to create xarray attributes with units,\n        ensuring consistency across all DataArrays in the system.\n\n    \"\"\"\n    attrs = {\"units\": StandardUnitsRegistry.format_unit_string(unit_label)}\n    attrs.update(overrides)\n    return attrs\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsRegistry.validate_unit_compatibility","title":"<code>validate_unit_compatibility(value, expected_unit)</code>  <code>staticmethod</code>","text":"<p>Validate that a value has compatible units.</p> <p>Performs unit compatibility validation by comparing the units attribute of a value object against an expected StandardUnitsLabels enum value. This validation ensures data consistency across the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Object to validate. Must have a 'units' attribute (typically   xarray DataArray, Dataset, or similar objects with units metadata)</p> required <code>expected_unit</code> <code>StandardUnitsLabels</code> <p>Expected unit label from StandardUnitsLabels enum</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if units match exactly, False otherwise.</p> <code>bool</code> <p>Returns False for any objects without units or on validation errors.</p> Validation Logic <ul> <li>Checks if value has 'units' attribute</li> <li>Compares string representation of units for exact match</li> <li>Handles exceptions gracefully by returning False</li> </ul> <p>Examples:</p> <p>Validating xarray DataArray:</p> <pre><code>&gt;&gt;&gt; import xarray as xr\n&gt;&gt;&gt; data = xr.DataArray([1, 2, 3], attrs={'units': 'degree_Celsius'})\n&gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n...     data, StandardUnitsLabels.temperature\n... )\nTrue\n</code></pre> <p>Invalid units:</p> <pre><code>&gt;&gt;&gt; data = xr.DataArray([1, 2, 3], attrs={'units': 'kelvin'})\n&gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n...     data, StandardUnitsLabels.temperature\n... )\nFalse\n</code></pre> <p>Missing units attribute:</p> <pre><code>&gt;&gt;&gt; data = xr.DataArray([1, 2, 3])  # No units\n&gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n...     data, StandardUnitsLabels.temperature\n... )\nFalse\n</code></pre> <p>Custom objects:</p> <pre><code>&gt;&gt;&gt; class TemperatureData:\n...     def __init__(self, units_str):\n...         self.units = units_str\n&gt;&gt;&gt; data = TemperatureData('degree_Celsius')\n&gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n...     data, StandardUnitsLabels.temperature\n... )\nTrue\n</code></pre> Error Handling <p>All exceptions (AttributeError, TypeError, ValueError) are caught and result in False return value. This ensures robust validation even with malformed or unexpected input objects.</p> Future Enhancements <p>This basic string comparison can be extended to support: - Pint unit compatibility checking (e.g., celsius vs kelvin) - Unit conversion compatibility - Dimensional analysis validation</p> Note <p>Currently performs exact string matching. Compatible but differently formatted units (e.g., 'deg_C' vs 'degree_Celsius') will return False.</p> Source code in <code>packages/seapopym/src/seapopym/standard/units.py</code> <pre><code>@staticmethod\ndef validate_unit_compatibility(value: Any, expected_unit: StandardUnitsLabels) -&gt; bool:\n    \"\"\"Validate that a value has compatible units.\n\n    Performs unit compatibility validation by comparing the units attribute\n    of a value object against an expected StandardUnitsLabels enum value.\n    This validation ensures data consistency across the pipeline.\n\n    Args:\n        value: Object to validate. Must have a 'units' attribute (typically\n              xarray DataArray, Dataset, or similar objects with units metadata)\n        expected_unit: Expected unit label from StandardUnitsLabels enum\n\n    Returns:\n        True if units match exactly, False otherwise.\n        Returns False for any objects without units or on validation errors.\n\n    Validation Logic:\n        - Checks if value has 'units' attribute\n        - Compares string representation of units for exact match\n        - Handles exceptions gracefully by returning False\n\n    Examples:\n        Validating xarray DataArray:\n        &gt;&gt;&gt; import xarray as xr\n        &gt;&gt;&gt; data = xr.DataArray([1, 2, 3], attrs={'units': 'degree_Celsius'})\n        &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n        ...     data, StandardUnitsLabels.temperature\n        ... )\n        True\n\n        Invalid units:\n        &gt;&gt;&gt; data = xr.DataArray([1, 2, 3], attrs={'units': 'kelvin'})\n        &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n        ...     data, StandardUnitsLabels.temperature\n        ... )\n        False\n\n        Missing units attribute:\n        &gt;&gt;&gt; data = xr.DataArray([1, 2, 3])  # No units\n        &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n        ...     data, StandardUnitsLabels.temperature\n        ... )\n        False\n\n        Custom objects:\n        &gt;&gt;&gt; class TemperatureData:\n        ...     def __init__(self, units_str):\n        ...         self.units = units_str\n        &gt;&gt;&gt; data = TemperatureData('degree_Celsius')\n        &gt;&gt;&gt; StandardUnitsRegistry.validate_unit_compatibility(\n        ...     data, StandardUnitsLabels.temperature\n        ... )\n        True\n\n    Error Handling:\n        All exceptions (AttributeError, TypeError, ValueError) are caught\n        and result in False return value. This ensures robust validation\n        even with malformed or unexpected input objects.\n\n    Future Enhancements:\n        This basic string comparison can be extended to support:\n        - Pint unit compatibility checking (e.g., celsius vs kelvin)\n        - Unit conversion compatibility\n        - Dimensional analysis validation\n\n    Note:\n        Currently performs exact string matching. Compatible but differently\n        formatted units (e.g., 'deg_C' vs 'degree_Celsius') will return False.\n\n    \"\"\"\n    try:\n        if not hasattr(value, \"units\"):\n            return False\n\n        expected_pint_unit = expected_unit.units\n        actual_units = getattr(value, \"units\", None)\n\n        if actual_units is None:\n            return False\n\n        # Basic string comparison - can be enhanced with pint compatibility checking\n        return str(actual_units) == str(expected_pint_unit)\n    except (AttributeError, TypeError, ValueError):\n        return False\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.units.StandardUnitsRegistry.get_supported_units","title":"<code>get_supported_units()</code>  <code>staticmethod</code>","text":"<p>Get all supported unit labels.</p> <p>Returns a tuple containing all available StandardUnitsLabels enum values, providing a complete inventory of units supported by the system.</p> <p>Returns:</p> Type Description <code>StandardUnitsLabels</code> <p>Tuple of all available StandardUnitsLabels enum values.</p> <code>...</code> <p>The tuple is ordered according to the enum definition.</p> <p>Examples:</p> <p>Getting all supported units:</p> <pre><code>&gt;&gt;&gt; units = StandardUnitsRegistry.get_supported_units()\n&gt;&gt;&gt; len(units)\n7\n&gt;&gt;&gt; StandardUnitsLabels.temperature in units\nTrue\n</code></pre> <p>Iterating over supported units:</p> <pre><code>&gt;&gt;&gt; for unit_label in StandardUnitsRegistry.get_supported_units():\n...     unit_str = StandardUnitsRegistry.format_unit_string(unit_label)\n...     print(f\"{unit_label.name}: {unit_str}\")\nheight: meter\nweight: gram\ntemperature: degree_Celsius\n...\n</code></pre> <p>Validation and enumeration:</p> <pre><code>&gt;&gt;&gt; supported = StandardUnitsRegistry.get_supported_units()\n&gt;&gt;&gt; user_unit = \"temperature\"  # From user input\n&gt;&gt;&gt; if any(unit.name == user_unit for unit in supported):\n...     unit_label = StandardUnitsLabels[user_unit]\n...     attrs = StandardUnitsRegistry.get_unit_attrs(unit_label)\n</code></pre> Use Cases <ul> <li>Dynamic unit validation in configuration parsing</li> <li>Building user interfaces with unit selection</li> <li>Documentation generation</li> <li>Testing completeness of unit handling</li> </ul> Note <p>The returned tuple is immutable and reflects the current state of the StandardUnitsLabels enum. Changes to the enum will be automatically reflected in subsequent calls.</p> Source code in <code>packages/seapopym/src/seapopym/standard/units.py</code> <pre><code>@staticmethod\ndef get_supported_units() -&gt; tuple[StandardUnitsLabels, ...]:\n    \"\"\"Get all supported unit labels.\n\n    Returns a tuple containing all available StandardUnitsLabels enum values,\n    providing a complete inventory of units supported by the system.\n\n    Returns:\n        Tuple of all available StandardUnitsLabels enum values.\n        The tuple is ordered according to the enum definition.\n\n    Examples:\n        Getting all supported units:\n        &gt;&gt;&gt; units = StandardUnitsRegistry.get_supported_units()\n        &gt;&gt;&gt; len(units)\n        7\n        &gt;&gt;&gt; StandardUnitsLabels.temperature in units\n        True\n\n        Iterating over supported units:\n        &gt;&gt;&gt; for unit_label in StandardUnitsRegistry.get_supported_units():\n        ...     unit_str = StandardUnitsRegistry.format_unit_string(unit_label)\n        ...     print(f\"{unit_label.name}: {unit_str}\")\n        height: meter\n        weight: gram\n        temperature: degree_Celsius\n        ...\n\n        Validation and enumeration:\n        &gt;&gt;&gt; supported = StandardUnitsRegistry.get_supported_units()\n        &gt;&gt;&gt; user_unit = \"temperature\"  # From user input\n        &gt;&gt;&gt; if any(unit.name == user_unit for unit in supported):\n        ...     unit_label = StandardUnitsLabels[user_unit]\n        ...     attrs = StandardUnitsRegistry.get_unit_attrs(unit_label)\n\n    Use Cases:\n        - Dynamic unit validation in configuration parsing\n        - Building user interfaces with unit selection\n        - Documentation generation\n        - Testing completeness of unit handling\n\n    Note:\n        The returned tuple is immutable and reflects the current state\n        of the StandardUnitsLabels enum. Changes to the enum will be\n        automatically reflected in subsequent calls.\n\n    \"\"\"\n    return tuple(StandardUnitsLabels)\n</code></pre>"},{"location":"api/seapopym/#labels","title":"Labels","text":""},{"location":"api/seapopym/#seapopym.standard.labels","title":"<code>seapopym.standard.labels</code>","text":"<p>Store all labels used in the No Transport model.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.CoordinatesLabels","title":"<code>CoordinatesLabels</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>A single place to store all labels as declared in coordinates module. It follow the cf_xarray convention.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.CoordinatesLabels--attributes","title":"Attributes","text":"<p>functional_group : str     Label for functional group dimension. time : str     Label for time dimension (T). Y : str     Label for latitude dimension (Y). X : str     Label for longitude dimension (X). Z : str     Label for depth/layer dimension (Z). cohort : str     Label for cohort dimension.</p> Source code in <code>packages/seapopym/src/seapopym/standard/labels.py</code> <pre><code>class CoordinatesLabels(StrEnum):\n    \"\"\"A single place to store all labels as declared in coordinates module. It follow the cf_xarray convention.\n\n    Attributes\n    ----------\n    functional_group : str\n        Label for functional group dimension.\n    time : str\n        Label for time dimension (T).\n    Y : str\n        Label for latitude dimension (Y).\n    X : str\n        Label for longitude dimension (X).\n    Z : str\n        Label for depth/layer dimension (Z).\n    cohort : str\n        Label for cohort dimension.\n\n    \"\"\"\n\n    functional_group = \"functional_group\"\n    time = \"T\"\n    Y = \"Y\"\n    X = \"X\"\n    Z = \"Z\"\n    cohort = \"cohort\"\n\n    @classmethod\n    def ordered(cls: CoordinatesLabels) -&gt; tuple[CoordinatesLabels, ...]:\n        \"\"\"Return all labels in the order they should be used in a dataset. It follow the CF convention.\n\n        Returns\n        -------\n        tuple[CoordinatesLabels, ...]\n            Tuple of ordered coordinate labels.\n\n        \"\"\"\n        return (cls.functional_group, cls.time, cls.Y, cls.X, cls.Z, cls.cohort)\n\n    @classmethod\n    def order_data(cls: CoordinatesLabels, data: xr.Dataset | xr.DataArray) -&gt; xr.Dataset:\n        \"\"\"Return the dataset with the coordinates ordered as in the CF convention.\n\n        Parameters\n        ----------\n        data : xr.Dataset | xr.DataArray\n            The input data.\n\n        Returns\n        -------\n        xr.Dataset\n            The data with transposed dimensions.\n\n        \"\"\"\n        return data.transpose(*cls.ordered(), missing_dims=\"ignore\")\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.labels.CoordinatesLabels.ordered","title":"<code>ordered()</code>  <code>classmethod</code>","text":"<p>Return all labels in the order they should be used in a dataset. It follow the CF convention.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.CoordinatesLabels.ordered--returns","title":"Returns","text":"<p>tuple[CoordinatesLabels, ...]     Tuple of ordered coordinate labels.</p> Source code in <code>packages/seapopym/src/seapopym/standard/labels.py</code> <pre><code>@classmethod\ndef ordered(cls: CoordinatesLabels) -&gt; tuple[CoordinatesLabels, ...]:\n    \"\"\"Return all labels in the order they should be used in a dataset. It follow the CF convention.\n\n    Returns\n    -------\n    tuple[CoordinatesLabels, ...]\n        Tuple of ordered coordinate labels.\n\n    \"\"\"\n    return (cls.functional_group, cls.time, cls.Y, cls.X, cls.Z, cls.cohort)\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.labels.CoordinatesLabels.order_data","title":"<code>order_data(data)</code>  <code>classmethod</code>","text":"<p>Return the dataset with the coordinates ordered as in the CF convention.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.CoordinatesLabels.order_data--parameters","title":"Parameters","text":"<p>data : xr.Dataset | xr.DataArray     The input data.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.CoordinatesLabels.order_data--returns","title":"Returns","text":"<p>xr.Dataset     The data with transposed dimensions.</p> Source code in <code>packages/seapopym/src/seapopym/standard/labels.py</code> <pre><code>@classmethod\ndef order_data(cls: CoordinatesLabels, data: xr.Dataset | xr.DataArray) -&gt; xr.Dataset:\n    \"\"\"Return the dataset with the coordinates ordered as in the CF convention.\n\n    Parameters\n    ----------\n    data : xr.Dataset | xr.DataArray\n        The input data.\n\n    Returns\n    -------\n    xr.Dataset\n        The data with transposed dimensions.\n\n    \"\"\"\n    return data.transpose(*cls.ordered(), missing_dims=\"ignore\")\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.labels.SeaLayers","title":"<code>SeaLayers</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumerate the sea layers.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.SeaLayers--attributes","title":"Attributes","text":"<p>EPI : tuple     Epipelagic layer (depth 1). UPMESO : tuple     Upper-mesopelagic layer (depth 2). LOWMESO : tuple     Lower-mesopelagic layer (depth 3).</p> Source code in <code>packages/seapopym/src/seapopym/standard/labels.py</code> <pre><code>class SeaLayers(Enum):\n    \"\"\"Enumerate the sea layers.\n\n    Attributes\n    ----------\n    EPI : tuple\n        Epipelagic layer (depth 1).\n    UPMESO : tuple\n        Upper-mesopelagic layer (depth 2).\n    LOWMESO : tuple\n        Lower-mesopelagic layer (depth 3).\n\n    \"\"\"\n\n    # NOTE(Jules): The following order of the layers declaration is important.\n    ## Since python 3.4 this order is preserved.\n    EPI = (\"epipelagic\", 1)\n    UPMESO = (\"upper-mesopelagic\", 2)\n    LOWMESO = (\"lower-mesopelagic\", 3)\n\n    @property\n    def standard_name(\n        self: SeaLayers,\n    ) -&gt; Literal[\"epipelagic\", \"upper-mesopelagic\", \"lower-mesopelagic\"]:\n        \"\"\"Return the standard_name of the sea layer.\n\n        Returns\n        -------\n        str\n            The standard name.\n\n        \"\"\"\n        return self.value[0]\n\n    @property\n    def depth(self: SeaLayers) -&gt; Literal[1, 2, 3]:\n        \"\"\"Return the depth of the sea layer.\n\n        Returns\n        -------\n        int\n            The depth index.\n\n        \"\"\"\n        return self.value[1]\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.labels.SeaLayers.standard_name","title":"<code>standard_name</code>  <code>property</code>","text":"<p>Return the standard_name of the sea layer.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.SeaLayers.standard_name--returns","title":"Returns","text":"<p>str     The standard name.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.SeaLayers.depth","title":"<code>depth</code>  <code>property</code>","text":"<p>Return the depth of the sea layer.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.SeaLayers.depth--returns","title":"Returns","text":"<p>int     The depth index.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.ConfigurationLabels","title":"<code>ConfigurationLabels</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>A single place to store all labels as declared in parameters module.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.ConfigurationLabels--attributes","title":"Attributes","text":"<p>fgroup_name : str     Name of the functional group. energy_transfert : str     Energy transfer coefficient. lambda_temperature_0 : str     Lambda temperature zero. gamma_lambda_temperature : str     Gamma lambda temperature. lambda_acidity_0 : str     Lambda acidity zero. gamma_lambda_acidity : str     Gamma lambda acidity. tr_0 : str     Turnover rate zero. gamma_tr : str     Gamma turnover rate. day_layer : str     Day layer position. night_layer : str     Night layer position. cohort : str     Cohort axis. timesteps_number : str     Number of timesteps. min_timestep : str     Minimum timestep. max_timestep : str     Maximum timestep. mean_timestep : str     Mean timestep. timestep : str     Forcing timestep. resolution_latitude : str     Latitude resolution. resolution_longitude : str     Longitude resolution. initial_condition_production : str     Initial condition for production. initial_condition_biomass : str     Initial condition for biomass. angle_horizon_sun : str     Angle of sun above horizon. compute_preproduction : str     Flag to compute preproduction. compute_initial_conditions : str     Flag to compute initial conditions. lambda_0 : str     Bednarsek lambda zero. survival_rate_0 : str     Bednarsek survival rate zero. gamma_survival_rate_acidity : str     Bednarsek gamma survival rate acidity. gamma_survival_rate_temperature : str     Bednarsek gamma survival rate temperature. density_dependance_parameter_a : str     Beverton-Holt density dependence parameter a. density_dependance_parameter_b : str     Beverton-Holt density dependence parameter b. w_pico : str     Weight for pico-phytoplankton. w_nano : str     Weight for nano-phytoplankton. w_micro : str     Weight for micro-phytoplankton. ks : str     Half-saturation constant.</p> Source code in <code>packages/seapopym/src/seapopym/standard/labels.py</code> <pre><code>class ConfigurationLabels(StrEnum):\n    \"\"\"A single place to store all labels as declared in parameters module.\n\n    Attributes\n    ----------\n    fgroup_name : str\n        Name of the functional group.\n    energy_transfert : str\n        Energy transfer coefficient.\n    lambda_temperature_0 : str\n        Lambda temperature zero.\n    gamma_lambda_temperature : str\n        Gamma lambda temperature.\n    lambda_acidity_0 : str\n        Lambda acidity zero.\n    gamma_lambda_acidity : str\n        Gamma lambda acidity.\n    tr_0 : str\n        Turnover rate zero.\n    gamma_tr : str\n        Gamma turnover rate.\n    day_layer : str\n        Day layer position.\n    night_layer : str\n        Night layer position.\n    cohort : str\n        Cohort axis.\n    timesteps_number : str\n        Number of timesteps.\n    min_timestep : str\n        Minimum timestep.\n    max_timestep : str\n        Maximum timestep.\n    mean_timestep : str\n        Mean timestep.\n    timestep : str\n        Forcing timestep.\n    resolution_latitude : str\n        Latitude resolution.\n    resolution_longitude : str\n        Longitude resolution.\n    initial_condition_production : str\n        Initial condition for production.\n    initial_condition_biomass : str\n        Initial condition for biomass.\n    angle_horizon_sun : str\n        Angle of sun above horizon.\n    compute_preproduction : str\n        Flag to compute preproduction.\n    compute_initial_conditions : str\n        Flag to compute initial conditions.\n    lambda_0 : str\n        Bednarsek lambda zero.\n    survival_rate_0 : str\n        Bednarsek survival rate zero.\n    gamma_survival_rate_acidity : str\n        Bednarsek gamma survival rate acidity.\n    gamma_survival_rate_temperature : str\n        Bednarsek gamma survival rate temperature.\n    density_dependance_parameter_a : str\n        Beverton-Holt density dependence parameter a.\n    density_dependance_parameter_b : str\n        Beverton-Holt density dependence parameter b.\n    w_pico : str\n        Weight for pico-phytoplankton.\n    w_nano : str\n        Weight for nano-phytoplankton.\n    w_micro : str\n        Weight for micro-phytoplankton.\n    ks : str\n        Half-saturation constant.\n\n    \"\"\"\n\n    # Functional group\n    fgroup_name = \"name\"\n    energy_transfert = \"energy_transfert\"\n    lambda_temperature_0 = \"lambda_temperature_0\"\n    gamma_lambda_temperature = \"gamma_lambda_temperature\"\n    lambda_acidity_0 = \"lambda_acidity_0\"\n    gamma_lambda_acidity = \"gamma_lambda_acidity\"\n    tr_0 = \"tr_0\"\n    gamma_tr = \"gamma_tr\"\n    day_layer = \"day_layer\"\n    night_layer = \"night_layer\"\n    # Cohorts\n    cohort = \"cohort\"  # New axis\n    timesteps_number = \"timesteps_number\"\n    min_timestep = \"min_timestep\"\n    max_timestep = \"max_timestep\"\n    mean_timestep = \"mean_timestep\"\n    # Forcing\n    timestep = \"timestep\"\n    resolution_latitude = \"resolution_latitude\"\n    resolution_longitude = \"resolution_longitude\"\n    initial_condition_production = \"initial_condition_production\"\n    initial_condition_biomass = \"initial_condition_biomass\"\n    # Kernel\n    angle_horizon_sun = \"angle_horizon_sun\"\n    compute_preproduction = \"compute_preproduction\"\n    compute_initial_conditions = \"compute_initial_conditions\"\n    # Bednarsek\n    lambda_0 = \"lambda_0\"\n    survival_rate_0 = \"survival_rate_0\"\n    gamma_survival_rate_acidity = \"gamma_survival_rate_acidity\"\n    gamma_survival_rate_temperature = \"gamma_survival_rate_temperature\"\n    # Beverton-Holt\n    density_dependance_parameter_a = \"density_dependance_parameter_a\"\n    density_dependance_parameter_b = \"density_dependance_parameter_b\"\n    # PFT\n    w_pico = \"w_pico\"\n    w_nano = \"w_nano\"\n    w_micro = \"w_micro\"\n    ks = \"ks\"\n</code></pre>"},{"location":"api/seapopym/#seapopym.standard.labels.ForcingLabels","title":"<code>ForcingLabels</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>A single place to store all labels as declared in forcing module.</p>"},{"location":"api/seapopym/#seapopym.standard.labels.ForcingLabels--attributes","title":"Attributes","text":"<p>global_mask : str     Global land/ocean mask. mask_by_fgroup : str     Mask specific to functional group. day_length : str     Day length. avg_temperature_by_fgroup : str     Average temperature by functional group. avg_acidity_by_fgroup : str     Average acidity by functional group. primary_production_by_fgroup : str     Primary production by functional group. min_temperature : str     Minimum temperature. mask_temperature : str     Mask based on temperature. cell_area : str     Area of grid cells. mortality_field : str     Mortality field. recruited : str     Recruited population. preproduction : str     Pre-recruitment population. biomass : str     Biomass. survival_rate : str     Survival rate. temperature : str     Temperature forcing. primary_production : str     Primary production forcing. acidity : str     Acidity forcing. food_efficiency : str     Food efficiency. chlorophyll_micro : str     Chlorophyll micro-phytoplankton. chlorophyll_nano : str     Chlorophyll nano-phytoplankton. chlorophyll_pico : str     Chlorophyll pico-phytoplankton.</p> Source code in <code>packages/seapopym/src/seapopym/standard/labels.py</code> <pre><code>class ForcingLabels(StrEnum):\n    \"\"\"A single place to store all labels as declared in forcing module.\n\n    Attributes\n    ----------\n    global_mask : str\n        Global land/ocean mask.\n    mask_by_fgroup : str\n        Mask specific to functional group.\n    day_length : str\n        Day length.\n    avg_temperature_by_fgroup : str\n        Average temperature by functional group.\n    avg_acidity_by_fgroup : str\n        Average acidity by functional group.\n    primary_production_by_fgroup : str\n        Primary production by functional group.\n    min_temperature : str\n        Minimum temperature.\n    mask_temperature : str\n        Mask based on temperature.\n    cell_area : str\n        Area of grid cells.\n    mortality_field : str\n        Mortality field.\n    recruited : str\n        Recruited population.\n    preproduction : str\n        Pre-recruitment population.\n    biomass : str\n        Biomass.\n    survival_rate : str\n        Survival rate.\n    temperature : str\n        Temperature forcing.\n    primary_production : str\n        Primary production forcing.\n    acidity : str\n        Acidity forcing.\n    food_efficiency : str\n        Food efficiency.\n    chlorophyll_micro : str\n        Chlorophyll micro-phytoplankton.\n    chlorophyll_nano : str\n        Chlorophyll nano-phytoplankton.\n    chlorophyll_pico : str\n        Chlorophyll pico-phytoplankton.\n\n    \"\"\"\n\n    global_mask = \"mask\"\n    mask_by_fgroup = \"mask_fgroup\"\n    day_length = \"day_length\"\n    avg_temperature_by_fgroup = \"average_temperature\"\n    avg_acidity_by_fgroup = \"average_acidity\"\n    primary_production_by_fgroup = \"primary_production_by_fgroup\"\n    min_temperature = \"min_temperature\"\n    mask_temperature = \"mask_temperature\"\n    cell_area = \"cell_area\"\n    mortality_field = \"mortality_field\"\n    recruited = \"recruited\"\n    preproduction = \"preproduction\"\n    biomass = \"biomass\"\n    survival_rate = \"survival_rate\"\n    temperature = \"temperature\"\n    primary_production = \"primary_production\"\n    acidity = \"acidity\"\n    food_efficiency = \"food_efficiency\"\n    chlorophyll_micro = \"chlorophyll_micro\"\n    chlorophyll_nano = \"chlorophyll_nano\"\n    chlorophyll_pico = \"chlorophyll_pico\"\n</code></pre>"},{"location":"examples/basic-example/","title":"Examples Overview","text":"<p>This section contains working examples demonstrating how to use SeapoPym.</p>"},{"location":"examples/basic-example/#available-examples","title":"Available Examples","text":""},{"location":"examples/basic-example/#1d-model-example","title":"1D Model Example","text":"<p>A complete tutorial showing:</p> <ul> <li>Data generation: Creating synthetic forcing data (temperature, primary production)</li> <li>Model configuration: Setting up functional groups with proper parameters</li> <li>Sequential execution: Running the model with context manager</li> <li>Parallel execution: Using Dask for distributed computing</li> <li>Time resolution: Degrading to weekly timesteps</li> <li>Visualization: Plotting biomass evolution over time</li> </ul> <p>View the 1D Model Example \u2192</p>"},{"location":"examples/basic-example/#optimization-example","title":"Optimization Example","text":"<p>A comprehensive guide to the optimization module, demonstrating:</p> <ul> <li>Synthetic Truth: Generating a \"ground truth\" simulation with known parameters</li> <li>Observation Generation: Creating synthetic observations with added noise</li> <li>Cost Function: Defining a cost function to compare model output with observations</li> <li>Genetic Algorithm: Using the optimization framework to recover the original parameters</li> <li>Calibration: Visualizing the convergence and fit of the optimized parameters</li> </ul> <p>View the Optimization Example \u2192</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>SeapoPym uses uv for dependency management and is structured as a monorepo workspace.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12</li> <li>uv package manager</li> </ul>"},{"location":"getting-started/installation/#installing-uv","title":"Installing uv","text":"<p>If you don't have uv installed, follow the official installation guide:</p> <p>uv Installation Documentation \u2192</p>"},{"location":"getting-started/installation/#installing-seapopym","title":"Installing SeapoPym","text":""},{"location":"getting-started/installation/#from-source-recommended","title":"From Source (Recommended)","text":"<p>Clone the repository and install:</p> <pre><code>git clone https://github.com/SeapoPym/seapopym.git\ncd seapopym\nuv sync\n</code></pre> <p>This installs both <code>seapopym</code> and <code>seapopym-optimization</code> packages in editable mode.</p>"},{"location":"getting-started/installation/#installing-only-core-package","title":"Installing Only Core Package","text":"<p>If you only need the core model:</p> <pre><code>uv pip install -e packages/seapopym\n</code></pre>"},{"location":"getting-started/installation/#installing-both-packages","title":"Installing Both Packages","text":"<p>To install both core and optimization:</p> <pre><code>uv pip install -e packages/seapopym -e packages/seapopym-optimization\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>Test that everything works:</p> <pre><code>import seapopym\nprint(f\"SeapoPym installed successfully!\")\n</code></pre>"},{"location":"getting-started/installation/#development-tools","title":"Development Tools","text":"<p>For contributing or running tests:</p> <pre><code>uv sync --group dev\n</code></pre> <p>This installs pytest, ruff, mypy, and other development tools.</p>"},{"location":"getting-started/installation/#documentation","title":"Documentation","text":"<p>To build the documentation locally:</p> <pre><code>uv sync --group docs\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installed, check out the Quick Start Guide to run your first model!</p>"},{"location":"getting-started/quickstart-optimization/","title":"Quick Start (Optimization)","text":"<p>SeapoPym Optimization describes a workflow to estimate model parameters using Genetic Algorithms (DEAP). Ideally suited for fitting the <code>NoTransportModel</code> to observed data (such as biomass time series or spatial maps), this module separates parameter definition, observation handling, and the optimization engine for clarity and reproducibility.</p>"},{"location":"getting-started/quickstart-optimization/#optimization-workflow","title":"Optimization Workflow","text":"<p>The optimization process follows four main steps:</p> <ol> <li>Prepare Observations: Wrap your reference data (xarray DataArray) into <code>Observation</code> objects (e.g., <code>TimeSeriesObservation</code>).</li> <li>Define Parameters: Use <code>Parameter</code> objects within your <code>FunctionalGroup</code> to specify which values to optimize and their bounds.</li> <li>Configure GA: Set up the <code>CostFunction</code> and <code>GeneticAlgorithmParameters</code> (population size, generations, mutation rates).</li> <li>Run &amp; Analyze: Instantiate the algorithm via <code>GeneticAlgorithmFactory</code> and run <code>.optimize()</code>.</li> </ol>"},{"location":"getting-started/quickstart-optimization/#minimal-example","title":"Minimal Example","text":"<p>This example demonstrates how to set up an optimization for a simplified case.</p> <pre><code>import numpy as np\nimport xarray as xr\nfrom seapopym_optimization.functional_group import (\n    NoTransportFunctionalGroup,\n    Parameter,\n    FunctionalGroupSet\n)\nfrom seapopym_optimization.observations.time_serie import TimeSeriesObservation\nfrom seapopym_optimization.cost_function.cost_function import CostFunction\nfrom seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm import (\n    GeneticAlgorithmParameters\n)\nfrom seapopym_optimization.algorithm.genetic_algorithm.factory import GeneticAlgorithmFactory\n\n# --- 1. Prepare Observations ---\n# Create fake observed data (e.g., biomass over time)\n# Note: Real observations require specific coordinates (e.g., 'time', 'latitude', 'longitude').\nobs_data = xr.DataArray(\n    data=np.random.rand(100),\n    coords={\"time\": np.arange(100)},\n    dims=\"time\",\n    name=\"biomass\"\n)\n# Wrap in an Observation object\nobs = TimeSeriesObservation(name=\"obs_sample\", observation=obs_data)\n\n# --- 2. Define Parameters ---\n# Define the Functional Group with some fixed values and some Parameters to optimize\nf_group = NoTransportFunctionalGroup(\n    day_layer=Parameter(value=1.5, min_value=0.0, max_value=3.0), # To optimize\n    night_layer=1.0,                                              # Fixed\n    energy_transfert=Parameter(value=0.1, min_value=0.01, max_value=0.5), # To optimize\n    lambda_temperature_0=0.5,\n    gamma_lambda_temperature=0.1,\n    tr_0=0.1,\n    gamma_tr=0.1,\n    name=\"example_group\"\n)\n\n# --- 3. Configure GA ---\n# Define GA hyperparameters\nga_params = GeneticAlgorithmParameters(\n    population_size=10,\n    generations=5,\n    mutation_probability=0.2,\n    crossover_probability=0.5\n)\n\n# Note: In a real scenario, you also need:\n# - 'forcing' (ForcingParameter containing Temperature/PP)\n# - 'configuration_generator' (NoTransportConfigurationGenerator)\n#\n# cost_function = CostFunction(\n#     configuration_generator=my_config_gen,\n#     functional_groups=FunctionalGroupSet([f_group]),\n#     forcing=my_forcing_param,\n#     kernel=None,\n#     observations=[obs],\n#     processor=TimeSeriesScoreProcessor(comparator=rmse_comparator)\n# )\n\n# --- 4. Run Optimization ---\n# Create the optimizer (Sequential for simple debugging, Parallel for speed)\n# ga = GeneticAlgorithmFactory.create_sequential(\n#     meta_parameter=ga_params,\n#     cost_function=cost_function\n# )\n\n# Run\n# results = ga.optimize()\n# print(results) # The logbook containing statistics\n</code></pre> <p>For a fully working executable example including model and forcing generation, see the Optimization Example.</p>"},{"location":"getting-started/quickstart-optimization/#next-steps","title":"Next Steps","text":"<ul> <li>Optimization Example: See a complete, executable example.</li> <li>API Reference: Explore the detailed API documentation for classes and functions.</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you run your first SeapoPym No-Transport model.</p>"},{"location":"getting-started/quickstart/#basic-workflow","title":"Basic Workflow","text":"<p>The typical workflow with SeapoPym:</p> <ol> <li>Prepare forcing data (temperature, primary production)</li> <li>Configure the model (forcing parameters, functional groups)</li> <li>Run the simulation</li> <li>Analyze results</li> </ol>"},{"location":"getting-started/quickstart/#minimal-example","title":"Minimal Example","text":"<pre><code>import xarray as xr\nfrom seapopym.model import NoTransportModel\nfrom seapopym.configuration.no_transport import (\n    NoTransportConfiguration,\n    ForcingParameter,\n    ForcingUnit,\n    FunctionalGroupParameter,\n    FunctionalGroupUnit,\n    FunctionalTypeParameter,\n    MigratoryTypeParameter,\n)\n\n# 1. Load forcing data\nforcing_data = xr.open_dataset('forcing.nc')\n\n# 2. Configure forcing\nforcing = ForcingParameter(\n    temperature=ForcingUnit(forcing=forcing_data['temperature']),\n    primary_production=ForcingUnit(forcing=forcing_data['pp']),\n)\n\n# 3. Define functional groups\nfunctional_groups = FunctionalGroupParameter(\n    functional_group=[\n        FunctionalGroupUnit(\n            name=\"zooplankton\",\n            energy_transfert=0.1668,\n            migratory_type=MigratoryTypeParameter(day_layer=0, night_layer=0),\n            functional_type=FunctionalTypeParameter(\n                lambda_temperature_0=1/150,\n                gamma_lambda_temperature=0.15,\n                tr_0=10.38,\n                gamma_tr=-0.11,\n            ),\n        ),\n    ]\n)\n\n# 4. Create configuration\nconfig = NoTransportConfiguration(\n    forcing=forcing,\n    functional_group=functional_groups,\n)\n\n# 5. Run model with context manager\nwith NoTransportModel.from_configuration(configuration=config) as model:\n    model.run()\n    # Extract results (copy for use outside context)\n    biomass = model.state['biomass'].copy()\n\n# 6. Analyze\nprint(biomass)\nbiomass.mean(['Y', 'X']).plot(x='T')\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-the-configuration","title":"Understanding the Configuration","text":""},{"location":"getting-started/quickstart/#functional-groups","title":"Functional Groups","text":"<p>Functional groups represent different biological components of the ecosystem (e.g., zooplankton, micronekton). Each functional group is defined by:</p> <ul> <li>Energy transfer (<code>energy_transfert</code>): Efficiency of energy transfer from primary production (typical values: 0.1-0.2)</li> <li>Migratory behavior (<code>migratory_type</code>): Vertical migration pattern defined by day and night depth layers</li> <li>Functional type (<code>functional_type</code>): Temperature response parameters that control how the group responds to environmental conditions</li> </ul> <pre><code>FunctionalGroupUnit(\n    name=\"zooplankton\",\n    energy_transfert=0.1668,                    # Energy transfer efficiency\n    migratory_type=MigratoryTypeParameter(\n        day_layer=0,                             # Depth layer during day\n        night_layer=0,                           # Depth layer during night\n    ),\n    functional_type=FunctionalTypeParameter(\n        lambda_temperature_0=1/150,              # Base mortality rate\n        gamma_lambda_temperature=0.15,           # Temperature effect on mortality\n        tr_0=10.38,                              # Reference temperature for recruitment\n        gamma_tr=-0.11,                          # Temperature sensitivity of recruitment\n    ),\n)\n</code></pre> <p>You can define multiple functional groups in a single simulation to represent different ecosystem components.</p>"},{"location":"getting-started/quickstart/#forcing-data","title":"Forcing Data","text":"<p>The No-Transport model requires two environmental forcing variables:</p> <pre><code>forcing = ForcingParameter(\n    temperature=ForcingUnit(forcing=temp_data),           # Sea temperature (\u00b0C)\n    primary_production=ForcingUnit(forcing=pp_data),      # Primary production (g/m\u00b2/day or similar)\n)\n</code></pre> <p>All forcing data must be <code>xarray.DataArray</code> with proper coordinates:</p> <ul> <li>T: Time coordinate</li> <li>Y: Latitude coordinate (can be single point for 1D models)</li> <li>X: Longitude coordinate (can be single point for 1D models)</li> <li>Z: Depth layer coordinate (for temperature)</li> </ul>"},{"location":"getting-started/quickstart/#understanding-the-model","title":"Understanding the Model","text":""},{"location":"getting-started/quickstart/#context-manager","title":"Context Manager","text":"<p>The recommended way to run SeapoPym models is with a context manager. This ensures automatic memory cleanup after execution, which is especially important for repeated simulations:</p> <pre><code>with NoTransportModel.from_configuration(configuration=config) as model:\n    model.run()\n    # Access results via model.state\n    biomass = model.state['biomass'].copy()  # Important: copy() for use outside context\n</code></pre> <p>The <code>copy()</code> method is important when extracting data for use outside the context manager.</p>"},{"location":"getting-started/quickstart/#model-state","title":"Model State","text":"<p>After running the model, results are stored in <code>model.state</code> as an <code>xarray.Dataset</code> containing:</p> <ul> <li>biomass: Total biomass per functional group (dimensions: functional_group, T, Y, X)</li> <li>recruited: Recruited biomass (dimensions: functional_group, T, Y, X)</li> <li>mortality_field: Mortality rate field (dimensions: functional_group, T, Y, X)</li> <li>primary_production_by_fgroup: Primary production allocated to each functional group</li> <li>And many other diagnostic variables...</li> </ul> <pre><code># Access results\nprint(model.state)\n\n# Extract specific variables\nbiomass = model.state['biomass']\nmean_biomass = biomass.mean(dim=['Y', 'X'])  # Average over space\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-netcdf-data","title":"Working with NetCDF Data","text":"<p>Most oceanographic data comes in NetCDF format. Here's how to load and prepare your data:</p> <pre><code>import xarray as xr\n\n# Load data\nds = xr.open_dataset('ocean_data.nc')\n\n# Check contents\nprint(ds)\n\n# Extract variables\ntemperature = ds['temp']\npp = ds['primary_production']\n\n# Check coordinates match SeapoPym requirements (T, Y, X, Z)\nprint(temperature.coords)\n</code></pre>"},{"location":"getting-started/quickstart/#visualizing-results","title":"Visualizing Results","text":"<p>Plot your results using xarray's built-in plotting:</p> <pre><code>import matplotlib.pyplot as plt\n\n# Time series of spatially-averaged biomass\nbiomass.mean(dim=['Y', 'X']).plot(x='T', hue='functional_group')\nplt.title('Mean Biomass Over Time')\nplt.legend()\nplt.show()\n\n# Spatial distribution at one time step (for 2D/3D models)\nbiomass.isel(T=0, functional_group=0).plot()\nplt.title('Biomass Spatial Distribution')\nplt.show()\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore complete examples with notebooks</li> <li>Check the API Reference</li> </ul>"},{"location":"images/","title":"Images","text":"<p>This directory contains figures and images used in the documentation.</p>"},{"location":"images/#usage","title":"Usage","text":"<p>Reference images in documentation:</p> <pre><code>![Description](images/figure_name.png)\n</code></pre> <p>With caption:</p> <pre><code>&lt;figure markdown&gt;\n  ![Model schematic](images/model_diagram.png)\n  &lt;figcaption&gt;Schematic representation of the No-Transport model&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre>"},{"location":"images/#guidelines","title":"Guidelines","text":"<ul> <li>Use descriptive filenames (e.g., <code>biomass_timeseries.png</code>, <code>model_schematic.svg</code>)</li> <li>Prefer vector formats (SVG, PDF) for diagrams</li> <li>Use PNG for raster images (plots, screenshots)</li> <li>Optimize file sizes before committing</li> <li>Include alt text for accessibility</li> </ul>"},{"location":"notebooks/","title":"Notebooks","text":"<p>This directory contains Jupyter notebooks that are included in the documentation.</p>"},{"location":"notebooks/#usage","title":"Usage","text":"<p>Notebooks placed here are automatically rendered by MkDocs when referenced in the documentation.</p>"},{"location":"notebooks/#adding-a-notebook-to-documentation","title":"Adding a Notebook to Documentation","text":"<ol> <li>Place your <code>.ipynb</code> file in this directory</li> <li>Reference it in a markdown file:</li> </ol> <pre><code>See the complete example: [Basic Model](notebooks/basic_example.ipynb)\n</code></pre> <ol> <li>Or add directly to navigation in <code>mkdocs.yml</code>:</li> </ol> <pre><code>nav:\n  - Examples:\n      - Basic Example: notebooks/basic_example.ipynb\n</code></pre>"},{"location":"notebooks/#tips","title":"Tips","text":"<ul> <li>Clear all outputs before committing (<code>Cell \u2192 All Output \u2192 Clear</code>)</li> <li>Keep notebooks focused and concise</li> <li>Add markdown cells with explanations</li> <li>Include visualizations for clarity</li> </ul>"},{"location":"notebooks/example_1d_model/","title":"A simple 1D model implementation","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\n\nfrom seapopym.configuration.no_transport import (\n    ForcingParameter,\n    ForcingUnit,\n    FunctionalGroupParameter,\n    FunctionalGroupUnit,\n    FunctionalTypeParameter,\n    MigratoryTypeParameter,\n    NoTransportConfiguration,\n)\nfrom seapopym.model import NoTransportModel\nfrom seapopym.standard.coordinate_authority import (\n    create_latitude_coordinate,\n    create_layer_coordinate,\n    create_longitude_coordinate,\n    create_time_coordinate,\n)\nfrom seapopym.standard.units import StandardUnitsLabels\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd import xarray as xr  from seapopym.configuration.no_transport import (     ForcingParameter,     ForcingUnit,     FunctionalGroupParameter,     FunctionalGroupUnit,     FunctionalTypeParameter,     MigratoryTypeParameter,     NoTransportConfiguration, ) from seapopym.model import NoTransportModel from seapopym.standard.coordinate_authority import (     create_latitude_coordinate,     create_layer_coordinate,     create_longitude_coordinate,     create_time_coordinate, ) from seapopym.standard.units import StandardUnitsLabels In\u00a0[2]: Copied! <pre>T_axis = create_time_coordinate(pd.date_range(\"2000-01-01\", \"2001-01-01\", freq=\"D\"))\nn = int(T_axis.size)\nt = np.linspace(0, 1, n)\ntemperature = 15 + 15 * np.sin(2 * np.pi * t)\nprimary_production = 10 + 5 * np.sin(2 * np.pi * t * 365)\n\ntemperature = xr.DataArray(\n    dims=[\"T\", \"Y\", \"X\", \"Z\"],\n    coords={\n        \"T\": create_time_coordinate(pd.date_range(\"2000-01-01\", \"2001-01-01\", freq=\"D\")),\n        \"Y\": create_latitude_coordinate([0]),\n        \"X\": create_longitude_coordinate([0]),\n        \"Z\": create_layer_coordinate([0]),\n    },\n    attrs={\"units\": StandardUnitsLabels.temperature},\n    data=temperature[:, np.newaxis, np.newaxis, np.newaxis],\n)\n\nplt.figure(figsize=(9, 3))\ntemperature[:, 0, 0].cf.plot.line(x=\"T\")\nplt.title(\"Temperature\")\nplt.show()\n\nprimary_production = xr.DataArray(\n    dims=[\"T\", \"Y\", \"X\"],\n    coords={\n        \"T\": create_time_coordinate(pd.date_range(\"2000-01-01\", \"2001-01-01\", freq=\"D\")),\n        \"Y\": create_latitude_coordinate([0]),\n        \"X\": create_longitude_coordinate([0]),\n    },\n    attrs={\"units\": \"g/m2/day\"},\n    data=np.random.rand(367, 1, 1),\n)\n\nplt.figure(figsize=(9, 3))\nprimary_production.plot()\nplt.title(\"Primary Production\")\nplt.show()\n\ndataset = xr.Dataset({\"temperature\": temperature, \"primary_production\": primary_production})\n</pre> T_axis = create_time_coordinate(pd.date_range(\"2000-01-01\", \"2001-01-01\", freq=\"D\")) n = int(T_axis.size) t = np.linspace(0, 1, n) temperature = 15 + 15 * np.sin(2 * np.pi * t) primary_production = 10 + 5 * np.sin(2 * np.pi * t * 365)  temperature = xr.DataArray(     dims=[\"T\", \"Y\", \"X\", \"Z\"],     coords={         \"T\": create_time_coordinate(pd.date_range(\"2000-01-01\", \"2001-01-01\", freq=\"D\")),         \"Y\": create_latitude_coordinate([0]),         \"X\": create_longitude_coordinate([0]),         \"Z\": create_layer_coordinate([0]),     },     attrs={\"units\": StandardUnitsLabels.temperature},     data=temperature[:, np.newaxis, np.newaxis, np.newaxis], )  plt.figure(figsize=(9, 3)) temperature[:, 0, 0].cf.plot.line(x=\"T\") plt.title(\"Temperature\") plt.show()  primary_production = xr.DataArray(     dims=[\"T\", \"Y\", \"X\"],     coords={         \"T\": create_time_coordinate(pd.date_range(\"2000-01-01\", \"2001-01-01\", freq=\"D\")),         \"Y\": create_latitude_coordinate([0]),         \"X\": create_longitude_coordinate([0]),     },     attrs={\"units\": \"g/m2/day\"},     data=np.random.rand(367, 1, 1), )  plt.figure(figsize=(9, 3)) primary_production.plot() plt.title(\"Primary Production\") plt.show()  dataset = xr.Dataset({\"temperature\": temperature, \"primary_production\": primary_production}) In\u00a0[3]: Copied! <pre>day_layer = 0\nnight_layer = 0\ntr_0 = 10.38\ngamma_tr = -0.11\nlambda_temperature_0 = 1 / 150\ngamma_lambda_temperature = 0.15\n\nf_groups = FunctionalGroupParameter(\n    functional_group=[\n        FunctionalGroupUnit(\n            name=f\"D{day_layer}N{night_layer}\",\n            energy_transfert=0.1668,\n            migratory_type=MigratoryTypeParameter(day_layer=day_layer, night_layer=night_layer),\n            functional_type=FunctionalTypeParameter(\n                lambda_temperature_0=lambda_temperature_0,\n                gamma_lambda_temperature=gamma_lambda_temperature,\n                tr_0=tr_0,\n                gamma_tr=gamma_tr,\n            ),\n        ),\n        FunctionalGroupUnit(\n            name=f\"D{day_layer}N{night_layer}_BIS\",\n            energy_transfert=0.1668 / 2,\n            migratory_type=MigratoryTypeParameter(day_layer=day_layer, night_layer=night_layer),\n            functional_type=FunctionalTypeParameter(\n                lambda_temperature_0=lambda_temperature_0 / 2,\n                gamma_lambda_temperature=gamma_lambda_temperature / 2,\n                tr_0=tr_0 / 2,\n                gamma_tr=gamma_tr / 2,\n            ),\n        ),\n    ]\n)\n\np_param = ForcingParameter(\n    temperature=ForcingUnit(forcing=dataset[\"temperature\"]),\n    primary_production=ForcingUnit(forcing=dataset[\"primary_production\"]),\n)\n\nparameters = NoTransportConfiguration(forcing=p_param, functional_group=f_groups)\n</pre> day_layer = 0 night_layer = 0 tr_0 = 10.38 gamma_tr = -0.11 lambda_temperature_0 = 1 / 150 gamma_lambda_temperature = 0.15  f_groups = FunctionalGroupParameter(     functional_group=[         FunctionalGroupUnit(             name=f\"D{day_layer}N{night_layer}\",             energy_transfert=0.1668,             migratory_type=MigratoryTypeParameter(day_layer=day_layer, night_layer=night_layer),             functional_type=FunctionalTypeParameter(                 lambda_temperature_0=lambda_temperature_0,                 gamma_lambda_temperature=gamma_lambda_temperature,                 tr_0=tr_0,                 gamma_tr=gamma_tr,             ),         ),         FunctionalGroupUnit(             name=f\"D{day_layer}N{night_layer}_BIS\",             energy_transfert=0.1668 / 2,             migratory_type=MigratoryTypeParameter(day_layer=day_layer, night_layer=night_layer),             functional_type=FunctionalTypeParameter(                 lambda_temperature_0=lambda_temperature_0 / 2,                 gamma_lambda_temperature=gamma_lambda_temperature / 2,                 tr_0=tr_0 / 2,                 gamma_tr=gamma_tr / 2,             ),         ),     ] )  p_param = ForcingParameter(     temperature=ForcingUnit(forcing=dataset[\"temperature\"]),     primary_production=ForcingUnit(forcing=dataset[\"primary_production\"]), )  parameters = NoTransportConfiguration(forcing=p_param, functional_group=f_groups) In\u00a0[4]: Copied! <pre># Recommended: Using context manager for automatic memory cleanup\nwith NoTransportModel.from_configuration(configuration=parameters) as model:\n    model.run()\n    # Extract results while still in context\n    biomass = model.state[\"biomass\"].copy()  # Important: copy() for external use\n</pre> # Recommended: Using context manager for automatic memory cleanup with NoTransportModel.from_configuration(configuration=parameters) as model:     model.run()     # Extract results while still in context     biomass = model.state[\"biomass\"].copy()  # Important: copy() for external use In\u00a0[5]: Copied! <pre>plt.figure(figsize=(9, 3))\nbiomass.mean([\"Y\", \"X\"]).plot(label=\"Zoo Seapopym\", x=\"T\", hue=\"functional_group\")\nplt.legend()\nplt.title(\"Evolution of the biomass\")\nplt.show()\n</pre> plt.figure(figsize=(9, 3)) biomass.mean([\"Y\", \"X\"]).plot(label=\"Zoo Seapopym\", x=\"T\", hue=\"functional_group\") plt.legend() plt.title(\"Evolution of the biomass\") plt.show() In\u00a0[6]: Copied! <pre>from dask.distributed import Client\n\nclient = Client()\n</pre> from dask.distributed import Client  client = Client() In\u00a0[7]: Copied! <pre>p_param = ForcingParameter(\n    temperature=ForcingUnit(forcing=dataset[\"temperature\"].chunk()),\n    primary_production=ForcingUnit(forcing=dataset[\"primary_production\"].chunk()),\n    parallel=True,\n)\nparameters = NoTransportConfiguration(forcing=p_param, functional_group=f_groups)\n</pre> p_param = ForcingParameter(     temperature=ForcingUnit(forcing=dataset[\"temperature\"].chunk()),     primary_production=ForcingUnit(forcing=dataset[\"primary_production\"].chunk()),     parallel=True, ) parameters = NoTransportConfiguration(forcing=p_param, functional_group=f_groups) In\u00a0[8]: Copied! <pre># Run parallel model with context manager\nwith NoTransportModel.from_configuration(configuration=parameters) as model:\n    model.run()\n    # Extract results for plotting\n    parallel_biomass = model.state[\"biomass\"].load().copy()\n</pre> # Run parallel model with context manager with NoTransportModel.from_configuration(configuration=parameters) as model:     model.run()     # Extract results for plotting     parallel_biomass = model.state[\"biomass\"].load().copy() In\u00a0[9]: Copied! <pre>plt.figure(figsize=(9, 3))\nparallel_biomass.mean([\"Y\", \"X\"]).plot(label=\"Zoo Seapopym\", x=\"T\", hue=\"functional_group\")\nplt.legend()\nplt.title(\"Evolution of the biomass\")\nplt.show()\n</pre> plt.figure(figsize=(9, 3)) parallel_biomass.mean([\"Y\", \"X\"]).plot(label=\"Zoo Seapopym\", x=\"T\", hue=\"functional_group\") plt.legend() plt.title(\"Evolution of the biomass\") plt.show() In\u00a0[10]: Copied! <pre>weekly_dataset = dataset.resample(T=\"1W\").mean().interpolate_na()\np_param = ForcingParameter(\n    temperature=ForcingUnit(forcing=weekly_dataset[\"temperature\"]),\n    primary_production=ForcingUnit(forcing=weekly_dataset[\"primary_production\"]),\n)\nparameters = NoTransportConfiguration(forcing=p_param, functional_group=f_groups)\n</pre> weekly_dataset = dataset.resample(T=\"1W\").mean().interpolate_na() p_param = ForcingParameter(     temperature=ForcingUnit(forcing=weekly_dataset[\"temperature\"]),     primary_production=ForcingUnit(forcing=weekly_dataset[\"primary_production\"]), ) parameters = NoTransportConfiguration(forcing=p_param, functional_group=f_groups) In\u00a0[11]: Copied! <pre>with NoTransportModel.from_configuration(configuration=parameters) as model:\n    model.run()\n    weekly_biomass = model.state[\"biomass\"].load().copy()\n</pre> with NoTransportModel.from_configuration(configuration=parameters) as model:     model.run()     weekly_biomass = model.state[\"biomass\"].load().copy() In\u00a0[12]: Copied! <pre>plt.figure(figsize=(9, 3))\nweekly_biomass.mean([\"Y\", \"X\"]).plot(label=\"Zoo Seapopym\", x=\"T\", hue=\"functional_group\")\nplt.legend()\nplt.title(\"Evolution of the biomass (Weekly)\")\nplt.show()\n</pre> plt.figure(figsize=(9, 3)) weekly_biomass.mean([\"Y\", \"X\"]).plot(label=\"Zoo Seapopym\", x=\"T\", hue=\"functional_group\") plt.legend() plt.title(\"Evolution of the biomass (Weekly)\") plt.show()"},{"location":"notebooks/example_1d_model/#a-simple-1d-model-implementation","title":"A simple 1D model implementation\u00b6","text":""},{"location":"notebooks/example_1d_model/#generating-data-for-the-1d-simulation","title":"Generating data for the 1D simulation\u00b6","text":"<p>Let's generate some data for the 1D simulation. In this NoTransport model, only temperature and primary production are required. The temperature is generated as a sine wave with a period of 1 year and the primary production is randomly generated.</p>"},{"location":"notebooks/example_1d_model/#initialize-the-model","title":"Initialize the model\u00b6","text":"<p>First we set up the model parameters. We will define two functional groups:</p> <ul> <li>The first group uses the commonly used parameters for zooplankton in Seapodym LMTL</li> <li>The second is a fictitious group where all parameters are arbitrarily divided by 2, simply to demonstrate that multiple functional groups can be declared in a single simulation</li> </ul>"},{"location":"notebooks/example_1d_model/#run-the-model-with-context-manager","title":"Run the model with context manager\u00b6","text":"<p>The new recommended way to use Seapopym models is with a context manager. This ensures automatic memory cleanup after model execution, which is especially important for genetic algorithms or repeated simulations.</p>"},{"location":"notebooks/example_1d_model/#plotting-the-results","title":"Plotting the results\u00b6","text":""},{"location":"notebooks/example_1d_model/#the-biomass-evolution-over-t","title":"The biomass evolution over T\u00b6","text":""},{"location":"notebooks/example_1d_model/#and-now-lets-do-it-in-parallel","title":"And now let's do it in parallel\u00b6","text":""},{"location":"notebooks/example_1d_model/#the-biomass-evolution-over-t","title":"The biomass evolution over T\u00b6","text":""},{"location":"notebooks/example_1d_model/#show-weekly-model-configuration","title":"Show weekly model configuration\u00b6","text":""},{"location":"notebooks/optimization_example/","title":"Optimization Example","text":"In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\n\nfrom seapopym.configuration.no_transport import ForcingParameter, ForcingUnit\nfrom seapopym.model import NoTransportModel\nfrom seapopym_optimization.algorithm.genetic_algorithm.factory import GeneticAlgorithmFactory\nfrom seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm import GeneticAlgorithmParameters\nfrom seapopym_optimization.algorithm.genetic_algorithm.logbook import LogbookCategory, LogbookIndex\nfrom seapopym_optimization.configuration_generator.no_transport_configuration_generator import (\n    NoTransportConfigurationGenerator,\n)\nfrom seapopym_optimization.cost_function.cost_function import CostFunction\nfrom seapopym_optimization.cost_function.metric import rmse_comparator\nfrom seapopym_optimization.cost_function.processor import TimeSeriesScoreProcessor\nfrom seapopym_optimization.functional_group import FunctionalGroupSet, NoTransportFunctionalGroup, Parameter\nfrom seapopym_optimization.functional_group.parameter_initialization import random_uniform_exclusive\nfrom seapopym_optimization.observations.observation import DayCycle\nfrom seapopym_optimization.observations.time_serie import TimeSeriesObservation\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd import xarray as xr  from seapopym.configuration.no_transport import ForcingParameter, ForcingUnit from seapopym.model import NoTransportModel from seapopym_optimization.algorithm.genetic_algorithm.factory import GeneticAlgorithmFactory from seapopym_optimization.algorithm.genetic_algorithm.genetic_algorithm import GeneticAlgorithmParameters from seapopym_optimization.algorithm.genetic_algorithm.logbook import LogbookCategory, LogbookIndex from seapopym_optimization.configuration_generator.no_transport_configuration_generator import (     NoTransportConfigurationGenerator, ) from seapopym_optimization.cost_function.cost_function import CostFunction from seapopym_optimization.cost_function.metric import rmse_comparator from seapopym_optimization.cost_function.processor import TimeSeriesScoreProcessor from seapopym_optimization.functional_group import FunctionalGroupSet, NoTransportFunctionalGroup, Parameter from seapopym_optimization.functional_group.parameter_initialization import random_uniform_exclusive from seapopym_optimization.observations.observation import DayCycle from seapopym_optimization.observations.time_serie import TimeSeriesObservation In\u00a0[11]: Copied! <pre>nb_days_by_year = 365\nnb_years = 5\ntotal_days = nb_days_by_year * nb_years\n\ntime_index = pd.date_range(\"2020-01-01\", periods=total_days, freq=\"D\")\n\n# Temperature: sinusoidal pattern\ntemp_data = (np.sin(np.linspace(0, (2 * np.pi) * nb_years, total_days)) * 5 + 20).reshape((total_days, 1, 1, 1))\ntemperature = xr.DataArray(\n    data=temp_data,\n    dims=[\"time\", \"latitude\", \"longitude\", \"depth\"],\n    coords={\n        \"time\": time_index,\n        \"latitude\": [0],\n        \"longitude\": [0],\n        \"depth\": [0],\n    },\n    name=\"temperature\",\n    attrs={\"units\": \"Celsius\", \"long_name\": \"Sea surface temperature\", \"standard_name\": \"sea_surface_temperature\"},\n)\n\n# Primary production: random + cosine pattern\npp_data = (\n    np.random.rand(total_days).reshape((total_days, 1, 1))\n    + np.cos(np.linspace(0, np.pi * nb_years, total_days)).reshape((total_days, 1, 1))\n    + 2\n) / 100\nprimary_production = xr.DataArray(\n    data=pp_data,\n    dims=[\"time\", \"latitude\", \"longitude\"],\n    coords={\n        \"time\": time_index,\n        \"latitude\": [0],\n        \"longitude\": [0],\n    },\n    name=\"primary_production\",\n    attrs={\"units\": \"kg/m^2/day\", \"long_name\": \"Primary production\", \"standard_name\": \"primary_production\"},\n)\n\n# Set axis attributes (critical for SeapoPym)\ntemperature.time.attrs = {\"axis\": \"T\"}\nprimary_production.time.attrs = {\"axis\": \"T\"}\ntemperature.latitude.attrs = {\"axis\": \"Y\"}\nprimary_production.latitude.attrs = {\"axis\": \"Y\"}\ntemperature.longitude.attrs = {\"axis\": \"X\", \"unit\": \"degrees_east\"}\nprimary_production.longitude.attrs = {\"axis\": \"X\"}\ntemperature.depth.attrs = {\"axis\": \"Z\"}\n\n# Create ForcingParameter\nforcing_param = ForcingParameter(\n    temperature=ForcingUnit(forcing=temperature),\n    primary_production=ForcingUnit(forcing=primary_production),\n)\n</pre> nb_days_by_year = 365 nb_years = 5 total_days = nb_days_by_year * nb_years  time_index = pd.date_range(\"2020-01-01\", periods=total_days, freq=\"D\")  # Temperature: sinusoidal pattern temp_data = (np.sin(np.linspace(0, (2 * np.pi) * nb_years, total_days)) * 5 + 20).reshape((total_days, 1, 1, 1)) temperature = xr.DataArray(     data=temp_data,     dims=[\"time\", \"latitude\", \"longitude\", \"depth\"],     coords={         \"time\": time_index,         \"latitude\": [0],         \"longitude\": [0],         \"depth\": [0],     },     name=\"temperature\",     attrs={\"units\": \"Celsius\", \"long_name\": \"Sea surface temperature\", \"standard_name\": \"sea_surface_temperature\"}, )  # Primary production: random + cosine pattern pp_data = (     np.random.rand(total_days).reshape((total_days, 1, 1))     + np.cos(np.linspace(0, np.pi * nb_years, total_days)).reshape((total_days, 1, 1))     + 2 ) / 100 primary_production = xr.DataArray(     data=pp_data,     dims=[\"time\", \"latitude\", \"longitude\"],     coords={         \"time\": time_index,         \"latitude\": [0],         \"longitude\": [0],     },     name=\"primary_production\",     attrs={\"units\": \"kg/m^2/day\", \"long_name\": \"Primary production\", \"standard_name\": \"primary_production\"}, )  # Set axis attributes (critical for SeapoPym) temperature.time.attrs = {\"axis\": \"T\"} primary_production.time.attrs = {\"axis\": \"T\"} temperature.latitude.attrs = {\"axis\": \"Y\"} primary_production.latitude.attrs = {\"axis\": \"Y\"} temperature.longitude.attrs = {\"axis\": \"X\", \"unit\": \"degrees_east\"} primary_production.longitude.attrs = {\"axis\": \"X\"} temperature.depth.attrs = {\"axis\": \"Z\"}  # Create ForcingParameter forcing_param = ForcingParameter(     temperature=ForcingUnit(forcing=temperature),     primary_production=ForcingUnit(forcing=primary_production), ) <pre>primary_production unit is kilogram / day / meter ** 2, it will be converted to gram / day / meter ** 2.\nprimary_production unit is kilogram / day / meter ** 2, it will be converted to gram / day / meter ** 2.\n</pre> In\u00a0[12]: Copied! <pre>config_generator = NoTransportConfigurationGenerator()\n\ntrue_energy = 0.1668\ntrue_tr = 10.38\n\nlambda_temperature_0 = 1 / 150\ngamma_lambda_temperature = 0.15\ngamma_tr = -0.11\n\n\ntrue_fg = NoTransportFunctionalGroup(\n    day_layer=0,\n    night_layer=0,\n    energy_transfert=true_energy,\n    lambda_temperature_0=lambda_temperature_0,\n    gamma_lambda_temperature=gamma_lambda_temperature,\n    tr_0=true_tr,\n    gamma_tr=gamma_tr,\n    name=\"Zooplankton\",\n)\n\ntrue_config = config_generator.generate(\n    functional_group_parameters=[true_fg], forcing_parameters=forcing_param, kernel=None\n)\n\nwith NoTransportModel.from_configuration(configuration=true_config) as model:\n    model.run()\n    # Extract biomass sum\n    true_biomass = model.state[\"biomass\"].sum(\"functional_group\")\n\n# Prepare noisy observation\nnoise = np.random.normal(0, 0.05 * np.mean(true_biomass), size=true_biomass.shape)\nobs_data = (true_biomass + noise).expand_dims({\"Z\": [0]})\nobs_data.name = \"biomass_obs\"\n\n# Create Observation object\nobservation = TimeSeriesObservation(name=\"synthetic_survey\", observation=obs_data, observation_type=DayCycle.DAY)\n\n# Visualize\nplt.figure(figsize=(10, 4))\ntrue_biomass.plot(label=\"True Model\")\nobs_data.plot(linestyle=\"None\", marker=\"o\", markersize=2, label=\"Observations\", alpha=0.5)\nplt.legend()\nplt.title(\"Synthetic Ground Truth vs Observations\")\nplt.show()\n</pre> config_generator = NoTransportConfigurationGenerator()  true_energy = 0.1668 true_tr = 10.38  lambda_temperature_0 = 1 / 150 gamma_lambda_temperature = 0.15 gamma_tr = -0.11   true_fg = NoTransportFunctionalGroup(     day_layer=0,     night_layer=0,     energy_transfert=true_energy,     lambda_temperature_0=lambda_temperature_0,     gamma_lambda_temperature=gamma_lambda_temperature,     tr_0=true_tr,     gamma_tr=gamma_tr,     name=\"Zooplankton\", )  true_config = config_generator.generate(     functional_group_parameters=[true_fg], forcing_parameters=forcing_param, kernel=None )  with NoTransportModel.from_configuration(configuration=true_config) as model:     model.run()     # Extract biomass sum     true_biomass = model.state[\"biomass\"].sum(\"functional_group\")  # Prepare noisy observation noise = np.random.normal(0, 0.05 * np.mean(true_biomass), size=true_biomass.shape) obs_data = (true_biomass + noise).expand_dims({\"Z\": [0]}) obs_data.name = \"biomass_obs\"  # Create Observation object observation = TimeSeriesObservation(name=\"synthetic_survey\", observation=obs_data, observation_type=DayCycle.DAY)  # Visualize plt.figure(figsize=(10, 4)) true_biomass.plot(label=\"True Model\") obs_data.plot(linestyle=\"None\", marker=\"o\", markersize=2, label=\"Observations\", alpha=0.5) plt.legend() plt.title(\"Synthetic Ground Truth vs Observations\") plt.show() In\u00a0[13]: Copied! <pre>optim_fg = NoTransportFunctionalGroup(\n    day_layer=0,\n    night_layer=0,\n    energy_transfert=Parameter(\n        lower_bound=0.001, upper_bound=0.5, name=\"energy_transfert\", init_method=random_uniform_exclusive\n    ),\n    lambda_temperature_0=lambda_temperature_0,\n    gamma_lambda_temperature=gamma_lambda_temperature,\n    tr_0=Parameter(lower_bound=0.0001, upper_bound=100, name=\"tr_0\", init_method=random_uniform_exclusive),\n    gamma_tr=gamma_tr,\n    name=\"Zooplankton\",\n)\n\ncost_func = CostFunction(\n    configuration_generator=config_generator,\n    functional_groups=FunctionalGroupSet([optim_fg]),\n    forcing=forcing_param,\n    kernel=None,\n    observations=[observation],\n    processor=TimeSeriesScoreProcessor(comparator=rmse_comparator),\n)\n\nga_params = GeneticAlgorithmParameters(POP_SIZE=30, NGEN=10, CXPB=0.9, MUTPB=1, INDPB=1 / 2, ETA=20.0)\n</pre> optim_fg = NoTransportFunctionalGroup(     day_layer=0,     night_layer=0,     energy_transfert=Parameter(         lower_bound=0.001, upper_bound=0.5, name=\"energy_transfert\", init_method=random_uniform_exclusive     ),     lambda_temperature_0=lambda_temperature_0,     gamma_lambda_temperature=gamma_lambda_temperature,     tr_0=Parameter(lower_bound=0.0001, upper_bound=100, name=\"tr_0\", init_method=random_uniform_exclusive),     gamma_tr=gamma_tr,     name=\"Zooplankton\", )  cost_func = CostFunction(     configuration_generator=config_generator,     functional_groups=FunctionalGroupSet([optim_fg]),     forcing=forcing_param,     kernel=None,     observations=[observation],     processor=TimeSeriesScoreProcessor(comparator=rmse_comparator), )  ga_params = GeneticAlgorithmParameters(POP_SIZE=30, NGEN=10, CXPB=0.9, MUTPB=1, INDPB=1 / 2, ETA=20.0) In\u00a0[14]: Copied! <pre>ga = GeneticAlgorithmFactory.create_sequential(meta_parameter=ga_params, cost_function=cost_func)\n\nprint(\"Starting optimization...\")\nresults = ga.optimize()\nprint(\"Optimization complete.\")\n</pre> ga = GeneticAlgorithmFactory.create_sequential(meta_parameter=ga_params, cost_function=cost_func)  print(\"Starting optimization...\") results = ga.optimize() print(\"Optimization complete.\") <pre>Starting optimization...\nOptimization complete.\n</pre> In\u00a0[15]: Copied! <pre># Find the best individual (minimum weighted fitness)\nbest_idx = results[(LogbookCategory.WEIGHTED_FITNESS, LogbookCategory.WEIGHTED_FITNESS)].idxmax()\nbest_individual = results.loc[best_idx]\n\n# Extract parameter values\nbest_params = best_individual[LogbookCategory.PARAMETER]\nprint(\"Best individual parameters:\")\nprint(best_params)\nprint(\n    f\"\\nBest fitness (RMSE): {best_individual[(LogbookCategory.WEIGHTED_FITNESS, LogbookCategory.WEIGHTED_FITNESS)]:.6f}\"\n)\n</pre> # Find the best individual (minimum weighted fitness) best_idx = results[(LogbookCategory.WEIGHTED_FITNESS, LogbookCategory.WEIGHTED_FITNESS)].idxmax() best_individual = results.loc[best_idx]  # Extract parameter values best_params = best_individual[LogbookCategory.PARAMETER] print(\"Best individual parameters:\") print(best_params) print(     f\"\\nBest fitness (RMSE): {best_individual[(LogbookCategory.WEIGHTED_FITNESS, LogbookCategory.WEIGHTED_FITNESS)]:.6f}\" ) <pre>Best individual parameters:\nname\nenergy_transfert     0.165965\ntr_0                10.503550\nName: (7, False, 27), dtype: float64\n\nBest fitness (RMSE): -2.207025\n</pre> In\u00a0[16]: Copied! <pre># Create functional group with optimized parameters\noptimized_fg = NoTransportFunctionalGroup(\n    name=\"Zooplankton\",\n    day_layer=0,\n    night_layer=0,\n    energy_transfert=best_params[\"energy_transfert\"],\n    gamma_tr=gamma_tr,\n    tr_0=best_params[\"tr_0\"],\n    gamma_lambda_temperature=gamma_lambda_temperature,\n    lambda_temperature_0=lambda_temperature_0,\n)\n\n# Generate configuration with optimized parameters\noptimized_config = config_generator.generate(\n    functional_group_parameters=[optimized_fg],\n    forcing_parameters=forcing_param,\n)\n\n# Run model with optimized parameters\nwith NoTransportModel.from_configuration(optimized_config) as optimized_model:\n    optimized_model.run()\n    optimized_biomass = optimized_model.state.biomass\n\noptimized_biomass = (\n    optimized_biomass.expand_dims({\"layer\": [0]}).isel(functional_group=0).drop_vars([\"functional_group\"])\n)\n</pre> # Create functional group with optimized parameters optimized_fg = NoTransportFunctionalGroup(     name=\"Zooplankton\",     day_layer=0,     night_layer=0,     energy_transfert=best_params[\"energy_transfert\"],     gamma_tr=gamma_tr,     tr_0=best_params[\"tr_0\"],     gamma_lambda_temperature=gamma_lambda_temperature,     lambda_temperature_0=lambda_temperature_0, )  # Generate configuration with optimized parameters optimized_config = config_generator.generate(     functional_group_parameters=[optimized_fg],     forcing_parameters=forcing_param, )  # Run model with optimized parameters with NoTransportModel.from_configuration(optimized_config) as optimized_model:     optimized_model.run()     optimized_biomass = optimized_model.state.biomass  optimized_biomass = (     optimized_biomass.expand_dims({\"layer\": [0]}).isel(functional_group=0).drop_vars([\"functional_group\"]) ) In\u00a0[18]: Copied! <pre>fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10))\n\n# Plot biomass comparison\ntrue_biomass.plot(ax=ax1, label=\"Observed\", linewidth=2)\noptimized_biomass.plot(ax=ax1, label=\"Optimized\", linestyle=\"--\", linewidth=2)\nax1.set_title(\"Biomass Comparison: Observed vs Optimized\")\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(\"Biomass\")\nax1.legend()\nax1.grid(True, alpha=0.3)\n\n# Plot fitness evolution\nfitness_evolution = (\n    results[LogbookCategory.WEIGHTED_FITNESS].groupby(LogbookIndex.GENERATION).agg([\"min\", \"mean\", \"max\"])\n)\n\nfitness_evolution[\"Weighted_fitness\"][\"max\"].plot(ax=ax2, label=\"Best\", marker=\"^\", linewidth=2)\nfitness_evolution[\"Weighted_fitness\"][\"mean\"].plot(ax=ax2, label=\"Mean\", marker=\"s\", linewidth=2)\nfitness_evolution[\"Weighted_fitness\"][\"min\"].plot(ax=ax2, label=\"Worst\", marker=\"o\", linewidth=2)\nax2.set_title(\"Fitness Evolution Across Generations\")\nax2.set_xlabel(\"Generation\")\nax2.set_ylabel(\"Weighted Fitness (RMSE)\")\nax2.legend()\nax2.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"\\nFinal RMSE: {best_individual[(LogbookCategory.WEIGHTED_FITNESS, LogbookCategory.WEIGHTED_FITNESS)]:.6f}\")\n</pre> fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10))  # Plot biomass comparison true_biomass.plot(ax=ax1, label=\"Observed\", linewidth=2) optimized_biomass.plot(ax=ax1, label=\"Optimized\", linestyle=\"--\", linewidth=2) ax1.set_title(\"Biomass Comparison: Observed vs Optimized\") ax1.set_xlabel(\"Time\") ax1.set_ylabel(\"Biomass\") ax1.legend() ax1.grid(True, alpha=0.3)  # Plot fitness evolution fitness_evolution = (     results[LogbookCategory.WEIGHTED_FITNESS].groupby(LogbookIndex.GENERATION).agg([\"min\", \"mean\", \"max\"]) )  fitness_evolution[\"Weighted_fitness\"][\"max\"].plot(ax=ax2, label=\"Best\", marker=\"^\", linewidth=2) fitness_evolution[\"Weighted_fitness\"][\"mean\"].plot(ax=ax2, label=\"Mean\", marker=\"s\", linewidth=2) fitness_evolution[\"Weighted_fitness\"][\"min\"].plot(ax=ax2, label=\"Worst\", marker=\"o\", linewidth=2) ax2.set_title(\"Fitness Evolution Across Generations\") ax2.set_xlabel(\"Generation\") ax2.set_ylabel(\"Weighted Fitness (RMSE)\") ax2.legend() ax2.grid(True, alpha=0.3)  plt.tight_layout() plt.show()  print(f\"\\nFinal RMSE: {best_individual[(LogbookCategory.WEIGHTED_FITNESS, LogbookCategory.WEIGHTED_FITNESS)]:.6f}\") <pre>\nFinal RMSE: -2.207025\n</pre>"},{"location":"notebooks/optimization_example/#optimization-example","title":"Optimization Example\u00b6","text":"<p>This notebook demonstrates how to use the <code>seapopym-optimization</code> package to estimate biological parameters for the <code>NoTransportModel</code>.</p> <p>We will:</p> <ol> <li>Generate synthetic data: Create forcing fields (temperature, primary production) and run the model with \"known\" parameters to create a ground truth.</li> <li>Create pseudo-observations: Add noise to the ground truth to simulate real data.</li> <li>Configure the Optimization: Define a cost function and which parameters to optimize.</li> <li>Run the Genetic Algorithm: Find the parameters that best fit the observations.</li> <li>Analyze Results: Visualize the convergence and the final fit.</li> </ol>"},{"location":"notebooks/optimization_example/#1-synthetic-data-generation","title":"1. Synthetic Data Generation\u00b6","text":"<p>We create synthetic temperature and primary production fields. SeapoPym requires specific <code>ForcingParameter</code> objects.</p>"},{"location":"notebooks/optimization_example/#2-generate-ground-truth","title":"2. Generate Ground Truth\u00b6","text":"<p>We define a functional group with \"true\" parameters and run the model.</p>"},{"location":"notebooks/optimization_example/#3-configuration-for-optimization","title":"3. Configuration for Optimization\u00b6","text":"<p>We define the same functional group but replace the \"unknown\" values with <code>Parameter</code> objects containing initial guesses and bounds.</p>"},{"location":"notebooks/optimization_example/#4-run-optimization","title":"4. Run Optimization\u00b6","text":"<p>We execute the genetic algorithm sequentially.</p>"},{"location":"notebooks/optimization_example/#5-analyze-results","title":"5. Analyze Results\u00b6","text":""},{"location":"scripts/","title":"Scripts","text":"<p>This directory contains Python scripts that are referenced in the documentation.</p>"},{"location":"scripts/#usage","title":"Usage","text":"<p>Scripts here can be included in documentation pages using snippets:</p>"},{"location":"scripts/#full-script-inclusion","title":"Full Script Inclusion","text":"<pre><code>```python title=\"scripts/run_model.py\"\n```\n</code></pre>"},{"location":"scripts/#partial-inclusion-with-line-numbers","title":"Partial Inclusion with Line Numbers","text":"<pre><code>```python\n```\n</code></pre>"},{"location":"scripts/#guidelines","title":"Guidelines","text":"<ul> <li>Keep scripts self-contained and runnable</li> <li>Add docstrings and comments</li> <li>Include example usage in script docstrings</li> <li>Name scripts descriptively (e.g., <code>run_basic_model.py</code>)</li> </ul>"}]}